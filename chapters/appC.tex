\chapter{流水线：基础与中级概念}

这个问题可能需要吸三袋烟的时间才能想明白。
—亚瑟•柯南•道尔，
《福尔摩斯探業集》

\section{引言}
本书的许多读者已经在其他教材（比如我们另一本更基础的教材 Computer Organization and
Design）或其他课程中了解了流水线的基础知识。因为第3章主要以这一材料为基础，所以读
者在学习该章之前，一定要熟悉本附录中讨论的概念。在阅读第2章时，快速回顾这一材料也
会有所帮助。

我们在本附录中首先介绍流水线的基础知识，包括数据路径含义的讨论、冒险的介绍、流
水线性能的研究。这一节介绍基本的五级 RISC，它是本附录其余部分的基础。C.2节介绍冒险
问题、它们为什么会导致性能问题、应当如何应对。C.3节讨论如何实际实现这个简单的五级
流水线，重点是控制和如何应对冒险。

C.4 节讨论流水线和指令集设计各个方面之间的相互关系，讨论了有关异常的重要主题以
及它们与流水线的相互交互。如果读者不熟悉精确与非精确中断的概念以及发生异常后的恢复
过程，会发现这一材料非常有用，因为它们是理解第3章中更高级方法的关键。

C.5 节讨论如何扩展五级流水线，以处理运行时间更长的浮点指令。C.6节在一个案例研究
中将这些概念结合在一起，这个案例研究的对象是一个深度流水线处理器—MIIPS R4000/
4400，它既包括八级整数流水线，又包括浮点流水线。

C.7节介绍了动态调度的概念，以及记分板在动态调度实现中的用法。它是作为交叉问题
介绍的，第3章的重点是动态调度方法，而这一部分内容可以充当第3章核心概念的引言。C.7
节还简单探讨了第3章中介绍的更复杂 Tomasulo算法。尽管不用引人记分板也能介绍和理解
Tomasulo 算法，但记分卡方法更简单、更易于理解。

\subsection{什么是流水线}

流水线是一种将多条指令重叠执行的实现技术。一条指令的执行需要多个操作，流水线技
术充分利用了这些操作之间的并行性。今天，流水线是用于加快 CPU速度的关键实现技术。

流水线就像是一条装配线。在汽车装配线上存在许多步骤，每一步骤负责汽车生产中的某
一项任务。每个步骤的执行与其他步骤是并行的，当然，装配的是不同汽车。在计算机流水线
中，流水线中的每个步骤完成指令的一部分。就像装配线一样，不同步骤并行完成不同指令的
不同部分。这些步骤中的每一步都称为流水级或流水段。流水级前后相连形成流水线—指令
在一端进入，通过这些流水级，在另一段退出，就像汽车在装配线中经历的过程一样。

在汽车装配线中，吞吐量定义为每小时生产的汽车数，由完整汽车退出装配线的频率决定。
与此类似，指令流水线的吞吐量由指令退出流水线的频率决定。由于流水线级是连在一起的，
所以所有流水级都必须做好同时工作的准备，就像我们在装配线中的要求一样。将一条指令在
流水线中下移一步所需的时间为处理器周期。由于所有各级同时进行，所以处理器周期的长度
由最缓慢流水线级所需时间决定，就像汽车装配线上的最长步骤决定了冷车沿生产线前进的时
间。在计算机中，这一处理器周期通常为1个时钟周期（有时为2个，但要少见得多）。

流水线设计者的目标是平衡每条流水线的长度，就像装配线的设计者尝试平衡装酿过程中
每个步骤的时间一样。如果各级达到完美平衡，那么每条指定在流水线处理器中的时
（假定为理想条件）等于：

\begin{verbatim}
    非流水线机器上每条指令的时间
    流水级的数目
\end{verbatim}

在这些条件下，因为实现流水线而得到的加速比等于流水级的数目，就像一个n级装配线在理
想情况下可以将汽车生产速度提高至8倍一样。但一般情况下，这些流水线之间不会达到完美
平衡；此外，流水线还会产生一些开销。因此，在流水线处理器上，处理每条指令的时间不会
等于其最低可能值，但可以非常接近。

流水线可以缩短每条指令的平均执行时间。根据我们认证的基准，这一缩短量可以计作每
条指令时钟周期数（CPI）的下降、时钟周期时间的缩短，或者这两者的组合。如果在开始时，
处理器需要多个时钟周期来处理一条指令，那我们通常将流水线的作用看作是降低了CPI。这
是我们来取的主视角。如果在开始时，处理器需要一个（长）时钟周期来处理一条指令，那就
认为流水线缩短了时钟周期时间。

流水线技术开发了串行指令流中各指令之间的并行度。它与某些加速技术不同（见第4章），
其真正的好处在于它对程序员是透明的。在这一附录中，我们将首先使用一个经典的五级流水
线来介绍流水线的概念；其他章节研究了更复杂流水线技术在现代处理器的应用。在更深入地
讨论流水线及其在处理器的应用之前，我们需要一个简单的指令集，下面将对此进行介绍。

\subsection{RISC指令集基础知识}
在本书中，我们一直使用 RISC（精筒指令集计算机）体系结构或载人-存储体系结构来说
明基本概念，当然，本书介绍的几乎所有思想都适用于其他处理器。本节介绍典型 RISC体系
结构的核心。在本附录及整本书中，我们的默认 RISC体系结构为 MIPS。在许多地方，其概念
非常类似，可以应用于任意 RISC。RISC体系结构有几个关键属性，这些属性大大简化了其实
现方式。

口 所有数据操作都是对寄存器中数据的操作，通常会改变整个寄存器（每个寄存器为32
位或64位）。
口只有载入和存储操作会影响到存储器，它们分别将数据从存储器移到寄存器或从寄存器
移到存储器。通常存在一些可以载人或存储低于一个完整寄存器的内容（例如，一个字
节、16位或32位）。
口 指令格式的数量很少，所有指令通常都是同一种大小。

这些简单属性极大地简化了流水线的实现，这也是如此设计这些指令集的原因。
为与本书其他部分保持一致，我们使用 MIPS64，它是 MIPS 指令集的64位版本。这些扩
展64位指令通常在助记符的开头或末尾加上字母D加以标识。例如，DADD 是加法指令的64位
版本，而LD则是载人指令的64位版本。

与其他RISC 体系结构类似，MIPS 指令集提供了32个寄存器，不过寄存器0的值总是0。
大多数 RISC体系结构，比如 MIPS，通常有以下三类指令（更多详细信息请参见附录A）。

（1） ALU 指令-
-这些指令取得两个寄存器或者一个寄存器与一个符号扩展立即数（称为
ALU 立即数指令，它们在 MIPS 中有一个16位偏移量），对它们进行操作，然后将结果存储到
第三个寄存器中。典型操作包括加（DADD）、减（DSUB）和逻辑运算（例如AND 或OR），后者不区
分32位和64位版本。这些指令的立即数版本使用相同助记符，但添加了后缀l。在 MIPS中，
包括算术运算的有符号形式和无符号形式；无符号形式的末尾有一个字母 U（例如，DADDU、DSUBU、
DADDIU），不会生成溢出异常（因此在32位和64位模式中是一样的）。

（2） 载入和存储指令——这些指令获取一个寄存器源（称为基址寄存器）和一个立即数字段
（在MIIPS中为16位，称为偏移量）作为操作数。基址寄存器的内容与符号扩展偏移量之和（称
为有效地址）用作存储器地址。对于载人指令，使用第二个寄存器操作数，用于存放从存储器
载入的数据。对于存储指令，第二个寄存器操作数是要存入存储器的数据源。载入字（LD）和
存储字（SD）等指令载人或存储整个 64位寄存器内容。

（3） 分支与跳转—分支是指控制的条件转移。在 RISC体系结构中，通常有两种方式来指
定分支条件：采用一组条件位（有时称为条件码），或者通过寄存器对之间、寄存器与零之间的
有限对比来设定。MIPS 采用后者。对于本附录，我们仅考虑两个寄存器是否相等。在所有RISC
体系结构中，分支目的地都是通过将符号扩展偏移量（MIPS 中为16位）加到当前程序计数器
中获得的。在许多 RISC体系结构中都提供了无条件眺转，但本附录中不会介绍跳转。

\subsection{RISC指令集的简单实现}

为了理解如何以流水线形式来实现 RISC指令集，需要理解在没有流水线时它是如何实现
的。这一节给出了一种简单实现，每一条指令最多需要5个时钟周期。我们将这一基本实现扩
展到流水线版本，从而大幅降低CPI。在所有不采用流水线的实现方式中，我们给出的方式并
非最经济或性能最高的。它的设计只是可以很自然地引向流水线实现。实现此指令集需要引入
几个不属于该体系结构的临时寄存器，引人它们是为了简化流水线。我们的实现将仅关注 RISC
体系结构中整数操作部分的流水线，这部分操作包括载人-存储字、分支和整数ALU操作。
这个 RISC子集中的每条指令都可以在最多5个时钟周期内实现。这5个时钟周期如下所述。

（1） 指令提取周期（IF）
将程序计数器（PC）发送到存储器，从存储器提取当前指令。向程序计数器加4（因为每
条指令的长度为4个字节），将程序计数器更新到下一个连续程序计数器。
（2） 指令译码/寄存器提取周期（功D）
对指令进行译码，并从寄存器堆中读取与寄存器源说明符相对应的寄存器。在读取寄存器
时对其进行相等测试，以确定是否为分支。必要时，对指令的偏移量字段进行符号扩展。符号
扩展后的偏移量添加到所实现的程序计数器上，计算出可能的分支目标地址。在较为积极的实
现方式中（我们稍后对此进行研究），如果这一条件判断的结果为真，则可以将分支目标地址存
储到程序计数器中，以在这一级的末尾完成分支。

指令译码与寄存器的读取是并行执行的，这可能是因为在RISC体系结构中，寄存器说明
符位于固定位置。这一技术称为固定字段译码。注意，我们可能会读取一个不会使用的寄存器，
这样做没有什么好处，但也不会损及性能。（读取非必需寄存器的确会浪费能量，但看重功率因
素的设计可以避免这一问题。）由于一个指令的立即数部分也位于同一位置，所以在需要符号扩
展立即数时，也是在这一周期计算的。

（3） 执行/有效地址周期（EX）
ALU对上一周期准备的操作数进行操作，根据指令类型执行三条指令之一。
口 存储器引用——ALU将基址寄存器和偏移量加到一起，形成有效地址。
口 寄存器-寄存器 ALU指令-
-ALU 对读自寄存器堆的值执行由ALU操作码指定的操作。
口 寄存器-立即数ALU指令——ALU对读自寄存器堆的第一个值和符号扩展立即数执行由
ALU操作码指定的操作。

在载人-存储体系结构中，有效地址与执行周期可以合并到一个时钟周期中，这是因为没有
指令需要计算数据地址并对数据执行操作。

（4） 存储访问（MEM）
如果该指令是一条载入指令，则使用上一周期计算的有效地址从存储器中读取数据。如果
是一条存储指令，则使用有效地址将从寄存器堆的第二个寄存器读取的数据写人存储器。

（5） 写回周期（WB）

口 寄存器-寄存器 ALU 指令或载入指令。
将结果写人寄存器堆，无论是来自寄存器系统（对于载人指令），还是来自 ALU（对于 ALU
措令）。

在这一实现中，分支指令需要2个周期，存储指令需要4个周期，所有其他指令需要5个
周期。假定分支频率为12\%，存储频率为10\%，对于这一典型指令分布，总CPI为4.54。但是，
无论是在获取最佳性能方面，还是在给定性能级别的情况尽量减少使用硬件方面，这一实施方
式都不是最优的；我们将对这一设计的改进留给读者作为练习，这里仅实现这一版本的流水线。

\subsection{RISC处理器的经典五级流水线}
我们几乎不需要进行什么改变就能实现上述执行过程的流水化，只要在每个时钟周期开始
一条新的指令就行。（想想我们为什么选择这种设计？）上一节的每个时钟周期都变成一个流水
线级——流水线中的一个周期。这样会得到表C-1所示的执行模式，这是绘制流水线结构的典
型方式。尽管每条指令需要5个周期才能完成，但在每个时钟周期内，硬件都会启动一条新的
命令，执行5个不同指令的某一部分。

表C-1 简单RISC流水线

*在每个时钟周期，提取另一条指令，并开始它的五周期执行过程。如果在每个时钟剧期都启动一条指令，其性能戴
多可达到非流水化处理器的5倍。流水线中各个阶段的名称与非流水线实现方式中各个周期的名称相同：「=指令提
取、1D-指今译码、EX 执行、MEM-存储器访问、WB=写回。

读者可能觉得很难相信流水线就是这样简单，它的确也并非如此简单。在本节和后续各节
中，我们将通过处理流水化带来的一些问题，使我们的 RISC流水线显得更“真实”。

首先，我们必须确定在处理器的每个时钟周期都会发生什么，确保不会在同一时钟周期内
对相同数据路径源执行两个不同操作。例如，不能要求同一个 ALU 同时计算有效地址和执行减
法操作。因此，我们必须确保流水线中的指令重叠不会导致这种冲突。幸运的是，RISC 指令集
比较简单，使资源评估变得相对容易。图C-1以流水线形式绘制了一个 RISC 数据路径的简化
版本。可以看到，主要功能单元是在不同周期使用的，因此多条指令的执行重蠢不会引人多少
冲突。从以下三点可以看出这一事实。

图C-1 流水线可以看作一系列随时间移动的数据路径。本图给出了数据路径不同部分之同的重 ，时钟
周期5（CC5）表示稳定状态。由于寄存器用作 ID级中的一个源和 WB 级中的目的地，所以它出
现两次。我们表示它在该级的一个部分进行读取，在另一部分进行写人，分别用左右两侧的实线
或虚线来表示。缩写IM表示指令存储器、DM表示数据存储器、CC表示时钟周期

第一，我们使用分离的指令存储器和数据存储器，我们通常用分离的指令和数据缓存来实
现它们（在第2章讨论）。在使用存储器时，在指令提取和数据存储器访问之间可能会发生冲
突，而使用分离缓存则可以消除这种冲突。注意，如果我们的流水线处理器的时钟周期等于非
流水线版本的时钟周期，则存储器系统必须提供5倍的带宽。这一需求的增加是提高性能的一
种成本。

第二，在两个阶段都使用了寄存器堆：一个是在 ID 中进行读取，一个是在WB 中进行写
人。这些用法是不同的，所以我们干脆在两个地方画出了寄存器堆。因此，每个时钟周期需要
执行两次读取和一次写人。为了处理对相同寄存器的多次读取和一次写入（稍后将会明了，还
有其他原因），我们在时钟周期的前半部分写寄存器，在后半部分读寄存器。

第三，图C-1没有涉及程序计数器。为了在每个时钟周期都启动一条新指令，我们必须在
每个时钟周期使程序计数器递增并存储它，这必须在『F 阶段完成，以便为下一条指令做好准备。
此外，还必须拥有一个加法器，在ID 期间计算潜在的分支目标。另外一个问题是分支在ID级
改变程序计数器。这样会导致一个问题，现在暂时忽略这一问题，但稍后就会对之进行处理。
尽管确保流水线中的指令不会试图在相同时间使用硬件资源是至关重要的，我们还必须确
保不同流水级中的指令不会相互干扰。这种分离是通过在连续流水级之间引入流水线寄存髒来
完戚的，这样会在时钟周期的末尾，将一个给定流水级得出的所有结果都存储到寄存器中，在
下一个时钟周期用作下一级的输人。图C-2给出了画有这些流水线寄存器的流水线。

图C-2 此流水线显示了连续流水级之间的流水线寄存器。注意，寄存器防止流水线相邻级中两条不同指
令之间的干扰。在将一条给定指令的数据从一级带至另一级的过程中，寄存器也扮演着重要角色。
寄存器的边沿触发特性（也就是说，取值在时钟沿即时改变）是非常关键的。否则，来自一条指
令的数据可能会干扰另一指令的执行！

尽管许多图形都为了简便而省略了这些寄存器，但它们是流水线正常操作所必需的。当然，
即使在一些没有采用流水化的多周期数据路径中也需要类似寄存器（因为只有寄存器中的值能
够在跨过时钟边界之后仍然得以保存）。在流水化处理器中，如果要将中间结果从一级传送到另
一级，而源位置与目标位置可能并非直接相邻，流水线寄存器也会在这种传送过程种扮演关键
角色。例如，要在存储指令中存储的寄存器值是在ID 期间读取的，但要等到 MEM 才会真正用
到；它在 MEM级中通过两个流水线寄存器传送给数据存储器。与此类似，ALU指令的结果是
在EX期间计算的，但要等到 WB 才会实际存储；它通过两个流水线寄存器才到达那里。有时
对流水线寄存器进行命名是有用的，根据这些寄存器所连接的流水级对其进行命名，所以这些
寄存器称为 IF/D、ID/EX、EX/MEM和 MEM/WB。

\subsection{流水化的基本性能问题}

流水化提高了 CPU指令吞吐量（单位时间内完成的指令数），但不会缩短单条指令的执行时
间。事实上，由于流水线控制会产生开销，它通常还会稍微延长每条指令的执行时间。尽管单条
指令的运行速度并没有加快，指令吞吐量的增长意味着程序可以更快速地运行，总执行时间缩短。
由于单条指令的执行时间并没有缩短，所以在下一节将会看到，这一事实限制了流水线的
实际深度。除了因为流水线延迟产生的局限之外，流水级之间的失衡和流化化开销也会造成限
制。流水级之间的不平衡会降低性能，这是因为时钟的运行速度不可能快于最缓慢的流水级。
流水线开销包含流水线寄存器延迟和时钟偏差。流水线寄存器增加了建立时间，也就是在发出
触发写操作的时钟信号之前，寄存器输入必须保持稳定的时间，而且时钟周期的传播也会产生
延迟。时钟偏差是时钟到达任意两个寄存器时刻之间的最大延迟，时钟周期的下限也受此因素
的影响。如果时钟周期小于时钟偏差与延迟开销之和，那时钟周期中就没有留给有用工作的时
间了，所以再增加流水线也就没用了。有兴趣的读者可以阅读Kunkel和Smith 等人的作品［1986］。
我们在第3章曾经看到，这一开销影响了 Pentium 4 相对于 Pentium II的性能改进。

例题
考虑上一节的非流水化处理器。假定其时钟周期为1 ns,ALU 运算和分支需要4
个周期，存储器操作需要5个周期。假定这些操作的相对频率分别为40\%、20\%和
40\%。假设由于时钟偏差和建立时间的原因，对处理器实现流水化使时钟增加了
0.2ns的开销。忽略所有延迟影响，通过流水线获得的指令执行速率加速比为多少？
解答
在非流水化处理器上，指令平均执行时间为：
\begin{verbatim}
    指令平均执行时间=时钟周期x平均CPI
    = Insx［（40%+ 20%）×4+40%×5］
    = In$×4.4
    = 4.4ns
\end{verbatim}
在流水线实现方式中，时钟的运行速度必须等于最慢流水级的速度加上开销时间，
也就是1+0.2=1.2ns；这就是指令平均执行时间。因此，通过流水化获得的加速比为：
流水化加速比 =韭流水化指令平均执行时间
\begin{verbatim}
    流水化指令平均执行时间
    1i1
    44ns=3.7倍
    1.2ns
\end{verbatim}
0.2ns的开销基本上确定了流水化的效能限度。如果此开销不受时钟周期变化的影
响，那么从 Amdahl定律可知，这一开销限制了加速比。

如果流水线中每条指令独立于所有其他指令，那这种简单的 RISC 流水线对于整数指令可
以正常运行。实际上，流水线中的指令可能是相互依赖的；这是下一节的主题。

\section{流水化的主要阻碍—流水线冒险}
有一些被称为冒险的情景，会阻止指令流中的下—条指令在其自己的指定时钟周期内执行。
冒险降低了流水化所能获得的理想加速比。共有以下三类冒险。

（1） 结构冒险，在重叠执行模式下，如果硬件无法同时支持指令的所有可能组合方式，就会
出现资源冲突，从而导致结构冒险。
（2）数据冒险，根据流水线中的指令重叠，指令之间存在先后顺序，如果一条指令取决于先
前指令的结果，就可能导致数据冒险。
（3）控制冒险，分支指令及其他改变程序计数器的指令实现流水化时可能导致控制冒险。

流水线中的冒险会使流水线停顿。为了避免冒险，经常要求在流水线中的一些指令延迟时，
其他一些指令能够继续执行。对于本附录中讨论的流水线，当一条指令被停顿时，在停顿指令
之后发射的所有指令也被停顿（这些指令在流水线中的位置不会远于停顿指令）。而在停顿指令
之前发射的指令必须继续执行（它们在流水线中的位置要更远一些），否则就永远不会清除冒险
情况。结果，在停顿期间不会提取新的指令。在本节将会看到几个有关流水线如何停顿操作的
示例—别担心，它们并没有听起来那么复杂！

\subsection{带有停顿的流水线性能}
停顿会导致流水线性能下降，低于理想性能。现在让我们看一个简单的公式，求解流水化
的实际加速比，首先从上一节的公式开始：
\begin{verbatim}
    非流水化指令平均执行时间
    流水化加速比=一流水化指令平均执行时间
    _韭流水化CPI ×非流水化时钟周期
    流水化CPI×流水化时钟周期
    -韭流水化CP! x韭流水化时钟間期
    流水化CPI
    流水化时钟周期
\end{verbatim}
流水化可以看作 CPI或时钟周期时间的降低。由于传统上使用CPI来比较流水线，所以让我们
从这里开始。流水化处理器的理想CPI几乎总等于1。因此，可以计算流水化CPI为：

流水化 CPI=理想 CPI+每条指令的流水线停顿时钟周期
=1+每条指令的流水线停顿时钟周期

如果忽略流水化的周期时间开销，并假定流水级之间达到完美平衡，则两个处理器的周期时间
相等，得到：

非流水化CPI
加速比=一
1+每条指令的流水线停顿周期

一种简单而重要的情景是所有指令的周期数都相同，必然等于流水级数目（也称为流水线深度）。
在这种情况下，非流水化 CPI 等于流水线的深度，得到：

流水深度
加速比=
1+每条指令的流水线停顿周期

如果没有流水线停顿，由此公式可以得到一个很直观的结果：流水化可以使性能提高的倍数等
于流水线深度。

或者，如果将流水化看作时钟周期时间的改善，那可以假定非流水化处理器的 CPI 以及流
水化处理器的CPI为1。于是得到：

流水化加速比一非流水化CP！
FL x韭流水化时钟周期
流水化CPI
流水化时钟周期
“个+每条指令的流水线停顿周币×非流水化时钟剧期
流水化时钟周期

当流水级达到完美平衡，而且没有开销时，流水化处理器的时钟周期小于非流水化处理器的时
钟周期，缩小因子等于流水线深度：

流水化时钟周期=韭流水化时钟周期
流水线深度
流水线深度-韭流水化时钟周期
流水化时钟周期

从而得到以下公式：

非流水化时钟周期
流水化加速比=。
1+每条指令的流水线停顿周期
流水化时钟周期
1+每条指令的流水线停顿周期
× 流水线深度

因此，如果没有停顿，则加速比等于流水级数，与我们对理想情况的直观感受一致。

\subsection{结构冒险}
当处理器以流水线方式工作时，指令的重叠执行需要实现功能单元的流水化和资源的复制，
以允许在流水线中出现所有可能的指令组合。如果由于资源冲突而不能容许某些指令组合，就
说该处理器存在结构冒险。

结构冒险最常见于某功能单元未能完全流水化的情况。这时，一系列使用该非流水化单元
的指令不能以每时钟周期执行一条指令的速度前进。结构冒险另一常见出现方式是某一资源的
复制不足以执行流水线申的所有指令组合。例如，处理器可能仅有一个寄存器堆写端口，但在
特定情况下，流水线可能希望在一个时钟周期内执行两个写操作。这就会生成结构冒险。

当指令序列遇到这种冒险时，流水线将会使这些指令中的一个停顿，直到所需单元可用为
止。这种停顿会增大 CPI值，不再是其通常的理想值1。

一些流水化处理器为数据和指令共享单存储器流水线。结果，当指令中包含数据存储器引
用时，它会与后面指令的指令引用冲突，如图C-3所示。为避免这一冒险，在发生数据存储器访
问时，我们使流水线停顿一个时钟周期。停顿通常被称为流水线气泡，或就称为气泡，因为它会
飘浮穿过流水线，占据空间却不执行有用工作。在讨论数据冒险时，将会看到另一种停顿类型。
时间（单位为时间周期）

图C-3 只要发生存储器引用，仅有一个存储器端口的处理器就会生成一次冲突。在这个示例中，载人指
令因为数据访问而使用存储器的同时，指令3希望从存储器中提取一条指令

设计者经常使用仅含有流水级名称的简图来表示停顿行为，如表C-2所示。在表C-2中展
示停顿时，指出那些没有执行操作的周期，只是将指令3向右移动（使其执行过程的开始与结
束都推后1个周期）。当流水线气泡穿过流水线时，其效果就是占据了该指令时隙的资源。

表C-2 流水线因为结构冒险而停顿—用一个存储器端口进行载入
时钟周期编号

* 如表中所示，载入指令实际强占了指令提取周期，导致流水线停顿一一在 4 号时钟周期没有启动指令（它通常会启
动指令：+3）。因为被提取的指令停顿，所以流水线中位于傳額指令之前的所有其他指令都可以正常进行。停顿周期
将继续穿过流水线，所以在8号时钟周期中没有完成指令。有时在绘制这 流水线表时，让流水线占据整个水平行，
指令了被移到下一行；无论采用哪种画法，效果都是一样的，因为指令：+3直到5号岡期才开蛤执行。因为以上形式
占据的空间较少，所以我们采用了这一形式。注意，本图假定指令：1和计2不是存储器引用。

例题
解答
让我们看看载人结构冒险的成本有多高。假定数据引用占总体的40%，流水化处
理器的理想 CPI 为1（忽略结构冒险）。假定与没有冒险的处理器相比，有结构冒
险处理器的时钟频率为其 1.05倍。不考虑所有其他性能损失，有结构冒险和无结
构冒险相比，哪种流水线更快？快多少？

有几种方法可以求解这一问题。最简单的一种可能就是计算两种处理器的平均指
令时间：

平均指令时间=CPI x时钟周期时间

由于没有停顿，所以理想处理器的平均指令时间就是时钟周期时间理想。有结构冒
险处理器的平均指令时间为：

平均指令时间=CPI x时钟周期时间
= （1+0.4×1）× 时钟周期时间團地
1.05
= 1.3×时钟周期时间理想

显然，没有结构冒险的处理器更快一些；根据平均指令时间的比值，我们可以得
出结论，无冒险处理器的速度快1.3倍。

为避免出现这种结构冒险，设计师可以为指令提供独立的存储器访问，既可以将
缓存分为独立的指令缓存和数据缓存，也可以使用一组缓冲区来保存指令，这种
缓冲区通常称为指令缓冲区。第5章讨论了分离缓存和指令缓冲区的思想。

如果其他因素相同，无结构冒险处理器的 CPI总是更低一些。那设计师为什么还会允许结
构冒险呢？其主要目的是为了降低单元成本，因为要实现所有功能单元的流水化，或者复制它
们，成本都太高昂了。例如，（为了防止上面示例中的结构冒险，）那些在每个周期内支持指令
与数据缓存访问的处理器需要有2倍的总存储器带宽，通常要求管脚处也可以承受较高的带宽。
与此类似，要完全实现浮点（FP）乘法器需要耗用大量门电路。如果结构冒险很罕见，那就不
值得花费这么大的代价来避免它。

\subsection{数据冒险}

流水化的主要效果是通过重叠指令的执行过程来改变它们的相对执行时间。这种重叠引入
了数据与控制冒险。当流水线改变对操作数的读写访问顺序，使该顺序不同于在非流水化处理
器上依次执行指令时的顺序，这时可能发生数据冒险。考虑以下指令的流水化执行：

\begin{verbatim}
    DADD
    RI.R2,R3
    DSUB
    R4,RI,R5
    AND
    R6,RL,R7
    OR
    R8,R1,R9
    XOR
    R10,R1,R11
\end{verbatim}

DADD之后的所有指令都用到了 DADD 指令的结果。如图 C-4所示，DADD 指令在 WB 流水级写入
R1 的值，但DSUB 指令在其TD 级中读取这个值。这一问题称为数据冒险。除非提前防范这种问
题，否则DSUB 指令将会读取错误值并试图使用它。事实上，DSUB 指令使用的值甚至是不确定的：
我们可能假定DSUB 使用的R！值总是由 DADD之前的指令赋值，认为这种假定是合乎逻辑的，但
事实并非总是如此。如果在 DADD和 DSUB 指令之间发生中断，DADD的WB 级将结束，而该点的
R1值将是DADD 的结果。这种不可预测的行为显然是不可接受的。

AND指令也会受到这种冒险的影响。从图C-4中可以看出，在5号时钟周期之前，R1的写
人操作是不会完成的。因此，在4号时钟周期读取寄存器的AND指令会得到错误结果。

图C-4 在后面三条指令中使用DADD 指令的结果时，由于要等到这些指令读取寄存器之后才会向其中写
入，所以会导致冒险

XOR指令可以正确执行，因为它的寄存器读取是在6号时钟周期进行的，这时寄存器写人已
经完成。OR指令的执行也不会招致冒险，因为我们在该时钟周期的后半部分执行寄存器堆读取，
而写入是在前半部分执行的。

下一小节将讨论一种技术，用于消除涉及 DSUB 和 AND指令的冒险停顿。

1.利用转发技术将数据冒险停顿减至最少

图C-4中提出的问题可以使用一种称为转发（forwarding）的简单硬件技术来解决（这一技
术也称为旁路，有时也称为短路）。转发技术的关键是认识到 DSUB 要等到 DADD实际生成结果之
后才会真正用到它。DADD将此结果放在流水线寄存器中，如果可以把它从这里转移到 DSUB 需要
的地方，那就可以避免出现停顿。根据这一观察结果，转发的工作方式如下所述。

（1）来自 EX/MEM 和 MEM/WB流水线寄存器的 ALU 结果总是被反馈回 ALU的输入端。
（2） 如果转发硬件检测到前一个 ALU 操作已经对当前 ALU 操作的源寄存器进行了写人操
作，则控制逻辑选择转发结果作为 ALU输人，而不是选择从寄存器堆中读取的值。

注意，采用转发技术后，如果 DSUB 停顿，则 DADD 将会完成，不会触发旁路。当两条指令之间发
生中断时，这一关系同样成立。

如图C-4中的示例所示，我们需要转发的结果可能不只来自前一条指令，还可能来自提前
两个周期启动的指令。图 C-5显示了带有旁通路径的示例，它重点突出了寄存器读取与写人的
时机。这一代码序列可以无停顿执行。

图C-5 一组依赖 DADD 结果的指令使用转发路径来避免数据冒险。DSUB 和 AND指令的输人是从流水线寄
存器转发到第一个 ALU输入。OR 接收的结果是通过寄存器堆转发而来的，这一点很容易实现，
只需要在周期的后半部分读取寄存器、在前半部分写人寄存器就能轻松完成，如寄存器上的虚线
所示。注意，转发结果可以到达任一ALU输人；事实上，ALU输人既可以使用来自相同流水线
寄存器的转发输入，也可以使用来自不同流水线寄存器的转发输人。例如，当AND 指令为AND R6.
RI,R4 时就会发生这种情况

可以将转发技术加以推广，将结果直接传送给需要它的功能单元：可以将一个功能单元输
出到寄存器中的结果直接转发到另一个功能单元的输人，而不仅限于同一单元的输出与输人之
间。例如以下序列：
\begin{verbatim}
    DADD
    R1,R2, R3
    LD
    R4,0（R1）
    SD
    R4,12（R1）
\end{verbatim}
为防止这一序列中出现停顿，我们需要将 ALU 输出值和存储器单元输出值从流水线寄存器转发
到 ALU 和数据存储器输人。图C-6给出了这一示例的所有转发路径。

图C-6 在MEM期间执行的存储操作需要转发操作数。载人结果由存储器输出转发到要存储的存储器输
入端。此外，ALU指令被转发到 ALU输人，供载入和存储指令进行地址计算（这与转发到另一
个 ALU操作没有区别）。如果存储操作依赖与其直接相邻的前一个 ALU操作（图中未示出），则
需要转发其结果，以防止出现停顿

2. 需要停顿的数据雷险
遗憾的是，并非所有潜在数据冒险都可以通过旁路方式处理。考虑以下指令序列：
\begin{verbatim}
    LD
    R1,0（R2）
    DSUB
    R4,R1,R5
    AND
    R6,RI,R7
    OR
    R8, R1,R9•
\end{verbatim}
这一示例中旁通路径的流水化数据路径如图C-7所示。这种情况不同于背靠背ALU操作的情景。
LD指令在4号时钟周期（其MEM周期）结束之前不会得到数据，而 DSUB 指令需要在该时钟周
期的开头就得到这一数据。因此，因为使用载入指令结果而产生的数据冒险无法使用简单的硬
件消除。如图C-7所示，这种转发路径必须进行时间上的回退操作—计算机设计师还不具备
这一能力！我们能够立即将该结果从流水线寄存器转发给 ALU，供 AND操作使用，该操作是在
载人操作之后两个时钟周期启动的。与此类似，OR指令也没有问题，因为它是通过寄存器堆接
收这个值的。对于 DSUB 指令，转发结果在时钟周期结束时才会抵达，这显然太晚了，因为这一
指令需要在此时钟周期开始时启动。

载入指令有一种不能单由转发来消除的延迟。而是需要增加一种称为流水线互锁，以保持
正确的执行模式。一般情况下，流水线互锁会检测冒险，并在该冒险被清除之前使流水线停顿。
在这种情况下，互锁使流水线停顿，让希望使用某一数据的指令等待，直到源指令生成该数据
为止。这种流水线互锁引入一次停顿或气泡，就像应对结构冒险时所做的一样。停顿指令的CPI
会增加，延长数目等于停顿的长度（在本例中为1个时钟周期）。

图 C-7 载入指令可以将其结果旁路至 AND 和 OR 指令，但不能旁路至 DSUB，因为这将意味著在“负向时
间”上转发结果

表C-3使用流水级名称显示了停顿前后的流水线。因为停顿会导致从 DSUB 开始的指令在时
间上向后移动1个周期，转发给AND指令的数据现在是通过寄存器堆到达的，而对于OR 指令根
本不需要转发。由于插入了气泡，需要增加一个周期才能完成这一序列。4号时钟周期内没有
启动指令（在6号周期没有指令完成）。

表C-3 在上半部分，我们可以看出为什么需要停顿：载入指令的MEM周期生成一个值，DSUB的EX周期
会需要它，而它们是同时发生的

\begin{verbatim}
    LD R1,0（R2）
    IF
    ID
    DSUB R4,RI,R5
    AND R6.R1.R7
    EX
    1D
    IF
    OR R8,R1,R9
    MEM
    EX
    D
    下
    WB
    MEM
    EX
    ID
    WB
    MEM
    EX
    WB
    MEM
    WB
    LD R1.0（R2）
    吓
    DSUB R4.RI.R5
    ID
    耶F
    AND R6.R1.R7
    EX
    ID
    IF
    OR R8.R1,R9
    *通过插入停顿可以解决这一部分，如下半部分所示。
    MEM
    停顿
    停顿
    停顿
    WB
    EX
    FF
    MEM
    EX
    jD
    WB
    MEM
    EX
    WB
    MEM
    WB
    -
\end{verbatim}

\subsection{分支冒险}
对于我们的 MIPS流水线，控制冒险造成的性能损失可能比数据冒险还要大。在执行分支
时，修改后的程序计数器的值可能等于（也可能不等于）当前值加4。回想一下，如果分支将
程序计数器改为其目标地址，它就是选中分支；否则就是未选中分支。如果指令i为选中分支，
通常会等到ID末尾，完成地址计算和对比之后才会改变程序计数器。

表C-4表明，处理分支的最简单方法是：一旦在ID期间（此时对指令进行译码）检测到分
支，就对该分支之后的指令重新取值。第一个 正F周期基本上是一次停顿，因为它从来不会执行
有用工作。读者可能已经注意到，如果分支未被选中，由于事实上已经正确地提取了指令，所
以IF级的重复是不必要的。我们稍后将开发几种机制，以充分利用这一事实。

表C-4 分支在五级流水线中导致一个周期的停顿
分支指令
项F
ID
EX
MEM
WB
分支后续指令
FF
ED
EX
MEM
WB
分支后续指令+1
TF
ID
EX
MEM
分支后续指令+2
IF
ID
EX

*分支指令之后的指令已被提取，但随后被忽略，在已经知道分支目标之后，重新开始提取操作。如果分支未被选中，
則分支后续指令的第二个 吓F就有些多余了，这一点可能比較明显。稍后将解决这一问题。

如果每个分支产生一个停顿周期，将会使性能损失10\%~30\%，具体取决于分支频率，所以
我们将研究一些用于应对这一损失的技术。

1. 降低流水线分支代价
有许多方法可以处理由分支延迟导致的流水线停顿，我们在这一小节讨论4种简单的编译
时机制。在这4种机制中，分支的操作是静态的，也就是说，在整个执行过程中，它们对每条
分支来说都是固定的。软件可以尝试利用硬件机制和分支行为方面的知识将分支代价降至最低。
第3章研究了功能更强大的软硬件技术，可以处理静态与动态分支预测。

处理分支的最简单机制是冻结或冲刷流水线，保留或删除分支之后的所有指令，直到知道
分支目标为止。这种解决方案的吸引力主要在于其软硬件都很简单。这也是表C-4所示流水线
中较早使用的解决方案。在这种情况下，分支代价是固定的，不能通过软件来缩减。

一种性能更高但仅略微复杂一点的机制是将每个分支都看作未选中分支，允许硬件继续执
行，就好像该分支未被执行一样。这时必须非常小心，在确切知道分支输入之前，不要改变处
理器状态。这一机制的复杂性在于必须要知道处理器状态可能何时被指令改变，以及如何“撒
销”这种改变。

在简单的五级流水线中，这种预测未选中机制的实现方式是继续提取指令，就好像分支指
令是一条正常指令一样。流水线看起来好像没有什么异常发生。但是，如果分支被选中，就需
要将已提取的指令转为空操作，重新开始在目标地址位提取指令。表C-5显示了这两种情况。

一种替代机制是将所有分支都看作选中分支。只要对分支指令进行了译码并计算了目标地
址，我们就假定该分支将被选中，开始在目标位置提取和执行。因为在我们的五级流水线中，
不可能在知道分支输出结果之前知道目标地址，所以这种方法对于这一流水线没有好处。在一
些处理器中，特别是那些拥有隐性设定条件代码或者拥有更强大（因此也更慢一些）分支条件
的处理器中，是可以在分支输出之前知道分支目标的，这时，预测选中机制可能就有意义了。
无论是在预测选中还是预测未选中机制中，编译器总是可以通过代码组织方式，使最频繁的路
径与硬件选择相匹配，从而提高性能。我们的第四种机制为编译器提高性能提供了更多的机会。

表C-5 分支未选中（上）和被选中（下）时的预测未选中机制和流水线序列
\begin{verbatim}
    未选中分支指令
    指令汁1
    指令计2
    指令汁3
    指令砂4
    企
    DD
    EX
    MEM
    WB
    DD
    EX
    MEM
    ID
    EX
    IF
    皿D
    WB
    MEM
    EX
    WB
    MEM
    E
    MEM
    WB
    选中指令分支
    IF
    DD
    指令计1
    EX
    空闲
    分支目标
    分支目标+1
    MEM
    空闲
    DD
    IF
    WB
    空闲
    EX
    1D
    空闲
    MEM
    EX
    分支目标+2
    下
    WE
    MEM
    EX
    WB
    MEM
    WB
\end{verbatim}
*当分支未被选中时（在IID 期间确定），我们提取未选中指令，继续进行。当在 IID 期间确定选中该分支时，则在分
支目标处重新开始提取。这将导致该分支后面的所有指令拌頓1个时钟周期。

在某些处理器中使用的第四种机制称为延迟分支。这一技术在早期RISC处理器中的使用非
常广泛，在五级流水线中的工作状态相当好。在延迟分支中，带有一个分支延迟的执行周期为：
\begin{verbatim}
    分支措令
    依序后续指令1
    选中时的分支目标
\end{verbatim}
依序后续指令位于分支延迟时隙中。无论该分支是否被选中，这一指令都会执行。表C-6中给
出具有分支延迟的五级流水线的流水线行为特性。尽管分支延迟可能长于一个1周期，但在实
际中，几乎所有具有延迟分支的处理器都只有单个指令延迟；如果流水线的潜在分支代价更长，
则使用其他技术。

\begin{verbatim}
    未选择分支指令
    分支延退指令（汁+1）
    分支延迟指令计2
    分支延迟指令汁3
    分支延迟指令：+4
    表C-6 无论分支是否选中，延迟分支的行为特性都是相同的
    下F
    ID
    怎
    EX
    DD
    卬
    MEM
    EX
    DD
    WB
    MEM
    EX
    ID
    邛F
    WB
    MEM WB
    EX MEM WB
    DD
    EX
    MEM WB
    选中分支指令
    分支延迟指令（汁1）
    EX
    ID
    MEM
    EX
    WB
    MEM
    WB
    分支目标
    EX
    MEM
    WB
    分支目标+1
    FF
    ID
    EX MEM WB
    分支目标+2
    IF
    ID EX MEM
    WB
\end{verbatim}

*延退时陈中的指令（对于 MIPS，只有一个延迟时際）被执行。如果分支未被选中，则继续执行分支延迟指令之后的
指令；如果分支被选中，則继续在分支目标处执行。当分支延迟时陈中的指令也是分支时，其含义就有些模糊：如
果该分支来被选中，延迟分支时陈中的分支应当怎么办呢？由于这一混淆，采用延迟分支的体系结构经常禁止在延
退时隙中放入分支。

编译器的任务是让后续指令有效并可用。因此使用了多种优化方式。图C-8给出了三种可
以调度分支延迟的方式。
\begin{verbatim}
    DADD R1,R2,R3
    if R2 = 0 then
    DADD RL,R2,R3
    if R1 = 0 then
    DSUB R4,R5,R6+
    DADD RI, R2, R3
    if R1 =0 then
    OR R7. R8. R9
    DSUB R4. R5,R6 4
    变为
    变为
    DSUB R4，
    R5，
    R6
    if R2 = 0 then
    DADD RI,R2.R3
    if R1 =0 then
    DADD R1,R2,R3
    1f R1 =0 then
    DSUB R4, R5, R6 +
    （a）来自分支之前
    （b）来自目标
    （c） 来自未选中指令
\end{verbatim}
图C-8 分支延迟时隙的调度。每一对中的上框显示调度之前的代码；下框表示调度后的代码。在（a）中，
延迟时隙内 入的是分支之前的一条不相关指令。这是最佳选择。策略（b）与（c）在策略（a）不可能实
现时使用。在（b）和（c）的序列中，由于分支条件中使用了RI，所有不能将 DADD 指令移到分支之后
（它的目的地是R1）。在（b）中，分支延迟时隙中填充了分支的目标指令；这时一般需要复制目标
指令，因为其他路径也可能会到达这一目标指令。当分支的选中机率很高时（比如循环分支）优
选策略（b）。最后，如（c）中所示，可以用未被选中的指令填充延迟时隙。为使这一优化方法能够对
（b）和（c）有效，当分支进入非预测方向时，必须可以执行经过移动的指令。这里所说的“可以”是
指浪费了工作量，但程序仍能正确执行。例如，当分支进入非预测方向时，R7成为一个未被用到
的临时寄存器，那（c）策略就属于这一情景

延迟分支调度的局限性源于：（1）对于可排在延迟时隙中的指令有限制；（2）我们在编译时
预测一个分支是否可能被选中的能力有限。为了提高编译器填充分支延迟时隙的能力，大多数
具有条件分支的处理器都引入了一种取消或废除分支。在取消分支中，指令包含了预测分支的
方向。当分支的行为与预期一致时，分支延迟时隙中的指令就像普通的延迟分支一样执行。当
分支预测错误时，分支延迟时隙中的指令转为空操作。

2. 分支机制的性能

这些机制的各自实际性能怎么样呢？假定理想CPI 为1，考虑分支代价的实际流水线加速
比为：

流水线加速比=-
流水线深度
1+分支导致的流水线停顿周期

由于：

分支导致的流水线停顿周期=分支频率x分支代价

得到：

流水线加速比=-
流水线深度
1+分支频率×分支代价

分支频率和分支代价可能都存在因为无条件分支和有条件分支导致的分量。但是，由于后者出
现得更为频繁，所以它们起主导作用。

例题
对于一个更深的流水线，比如在 MIPS R4000 中，在知道分支目标地址之前至少需
要三个流水级，在计算分支条件之前需要增加一个周期，这里假定条件比较时寄
存器中没有停顿。三级延迟导致表C-7中所列三种最简单预测机制的分支代价。
假定有如下频率，计算因分支使该流水线的CPI 增加了多少。
无条件分支
4%
有条件分支、未选中
6%
条件分支、选中
10%
表C-7 三种最简单预测机制对于一个较深流水线的分支代价
分支机制
冲刷流水线
预测选中
预测未选中
无条件分支代价
未选中分支代价
2
3
2
3
2
o
选中分支代价
3
2
3
解答
将无条件、有条件未选中和有条件选中分支的相对频率乘以各自的代价，就可以
求出 CPI。结果如表C-8所示。
表C-8 对于三种分支预测机制及较深流水线的CP1代价
分支成本对CPI的地加量
分支机制
无条件分支
未选中条件分支
选中条件分支
事件频率
4%
6%
10%
停顿流水线
0.08
0.18
0.30
预测选中
0.08
0.18
0.20
预测未选中
0.08
0.00
0:30
所有分支
20%
0.56
0.46
0.38

这些机制之间的差别大体随这一较长的延迟而增大。如果基础CPI为1，分支是唯
一的停顿源，则理想流水线的速度是使用停顿流水线机制的流水线的1.56 倍。预
测未选中机制在相同假定条件下优于停顿流水线机制，为其1.13倍。

\subsection{通过预测降低分支成本}
当流水线变得越来越深，而且分支的潜在代价增加时，仅使用延迟分支及类似机制就不够
了。这时需要寻求一种更积极的方式来预测分支。这些机制分为两类：依赖编译时可用信息的
低成本静态机制；根据程序特性对分支进行动态预测的策略。下面将讨论这两种方法。

\subsection{静态分支预测}
改进编译时分支预测的一种重要方式是利用先前运行过程收集的一览数据。之所以值得这
样做，是因为人们观测到分支的行为特性经常是双峰分布的；也就是说，各个分支经常是严重
偏向于选中或未选中两种情景之一。图C-9显示了使用这一策略成功地进行了分支预测。使用
相同输入数据来运行程序，以收集一览数据；其他研究表明，如果改变输人，使不同运行的一
览数据发生变化，只会使基于一览数据的预测准确度有微小变化。

任意分支预测机制的有效性都同时取决于机制的精度和条件分支的频率，在 SPEC中，其
变化范围为3\%~24\%。整数程序的错误预测率较高，此类程序的分支频率通常较高，这一事实
是静态分支预测的主要限制。在下一节中，我们考虑动态分支预测器，最新的处理器都采用这
种机制。

图C-9 对于一种基于一览数据的预测器，SPEC92的错误预测率变化幅度很大，但浮点程序通常优于整
型程序，前者的平均错误预测率为9\%，标准偏差为4\%，后者的平均错误预测率为15\%，标准
偏差为 5\%。实际性能取决于预测精度和分支频率，其变化范围为 3\%~24\%

\subsection{动态分支预测和分支预测缓冲区}
最简单的动态分支预测机制是分支预测缓冲区或分支历史表。分支预测缓冲区是一个小型
存储器，根据分支指令地址的低位部分进行索引。这个存储器中包含一个位（bit），表明该分支
最近是否曾被选中。这一机制是最简单的缓冲区形式；它没有标志，仅当分支延迟过长，超过
可能目标PC计算所需要的时间时，用于缩短分支延迟。

采用这样一种缓冲区时，我们事实上并不知道预测是否正确—它也可能是由另外一个具
有相同低位地址的分支放人的。这个预测就是一种提示，我们假定它是正确的，并开始在预测
方向上开始提取。如果这一提示最终是错误的，那将预测位反转后存回。

这个缓冲区实际上就是一个缓存，对其所有访问都会命中，而且在后面可以看到，缓冲区
的性能取决于两点：对所关注分支的预测频繁程度，该预测在匹配时的准确度。在分析性能之
前，对分支预测机制的精度进行一点微小而重要的提升是很有用的。

这种简单的1位预测机制在性能上有一处短板：即使某个分支几乎总是被选中，在其未被
选中时，我们也可能会得到两次错误预测，而不是一次，因为错误预测会导致该预测位反转。
为了弥补这一弱点，经常使用2位预测机制。在两位预测机制中，预测必须错过两次之后
才会进行修改。图C-10给出了2位预测机制的有限状态处理器。

分支预测缓冲可以实现为一个小的特殊“缓存”，在IF 流水线中使用指令地址进行访问，
或者实现为一对比特，附加到指令缓存中的每个块，并随指令一起提取。如果指令的译码结果
为一个分支，并且该分支被预测为选中，则在知道PC 之后立即从目标位置开始提取。否则，
继续进行顺序提取和执行。如图C-10所示，如果预测结果错误，将改变预测位。

图C-10 2位预测机制中的状态。许多分支被选中和不被选中的概率并非均等，而是严重偏向其中一种状
态，对于此类分支，2位预测器的错误预测率经常低于1位预测器。在这种预测器中，使用2个
数位对系统中的4种状态进行编码。这一2位机制实际上是一种更具一般性的机制的具体化，
这种通用机制对于预测缓冲区中的每一项都有n位饱和计数器。对于一个n位计数器，其取值
介于2至2-1之间：当计数器大于或等于其最大值（2-1）的一半时，分支被预测为选中；否
则，预测其未选中。对n位预测器的研究已经证明，2位预测器的效果几乎与n位预测器相同，
所以大多数系统都采用2位分支预测器，而不是更具一般性的n位预测器

在实际应用程序中，如果使用每项两位的分支预测缓冲区，可以预测得到什么样的准确度？
图C-11显示，对于 SPEC89基准测试，一个拥有4096项的分支预测缓冲区将得到超过99%~82%
的预测准确度，或者说错误预测率为1\%~18\%。根据2005年的标准，一个4K 项的缓冲区（比
如得出上述结果的缓冲区）算是很小了，较大的缓冲区可以得到更好一点的结果。

由于我们尝试开发更多的IP，所以分支预测的准确度变得非常关键。在图C-11中可以看
出，整数程序的预测器精度低于循环密集的科学程序（前者的分支频率通常也更高一些）。我们
可以采用两种方式来解决这一问题：增大缓冲区的大小，增加每种预测机制的准确度。但如图
C-12所示，一个拥有4000项的缓冲区，其性能大体与无限缓冲区相当，至少对于SPEC这样的
基准测试如此。图C-12中的数据清楚地表明缓冲区的命中率并非主要限制因素。前面曾经提到，
仅提高每个预测器的位数而不改变预测器结构，其影响也是微乎其微的。因此，我们需要研究
一下如何提高每种预测器的精度。

对于 SPEC89基准测试，4096项2位预测缓冲区的预測准确度。整数基准测试（gCC、espresso、
eantott 和 1i）的预测错误率大体高于浮点程序，前者的均值为11%，后者为4%。忽略浮点内核
（nasa7、matrix300和tomcatv）仍然会使浮点基准测试的准确度高于整数基准测试。收集这些数
据及本节其余数据的分支预测研究采用IBM Power 体系结构及针对该系统的优化代码执行。参
见 Pan、So 和 Rameh 等人的文献［1992］。尽管这些数据来自一部分 SPEC 基准测试的较早版本，
但新的基准测试结果值更大一些，行为特性稍差一些，整数基准测试尤其如此

对于 SPEC89基准测试，4096项2位预测缓冲区与无限缓冲区的预测准确度对比。尽管这些数
据是针对一部分SPEC基准测试的较早版本收集的，但较新版本的结果也大体相当，只是可能
需要8000项来匹配一个无限2位预测器

\section{如何实现流水化}
在开始介绍基本流水化之前，需要回顾一下 MIPS非流水版本的一种简单实现。

\subsection{MIPS的简单实现}
本节将继续C.1节的风格，首先给出一种简单的非流水化实现，然后是流水化实现。但我
们这一次的例子是专门针对 MIPS 体系结构的。

在这一小节，我们主要关注 MIPS 中一部分整数运算的流水线，其中包括载入-存储字、等
于零时分支和整数 ALU 运算。在本附录的后半部分将整合这些基础浮点操作。尽管我们仅讨论
MIPS 的一个子集，但这些基本原则可以扩展到对所有指令的处理。我们最初使用分支指令的一
种不太积极的实现方式。在本节结束时，将展示如何实现一种更积极的版本。

每种 MIIS 指令都可以在最多5个时钟周期中实现。这5个时钟周期分述如下。
（1） 指令提取周期（IF）。
IR 个 Mem［PC］；
NPC 个 PC + 4；

操作—一送出PC，并将指令从存储器提取到指令寄存器中（IR）；将PC递增4，以完成下
一顺序指令的寻址。IR用于保存将在后续时钟周期中需要的指令；与此类似，寄存器 NPC用于
保存下一顺序PC。

（2）指令译码/寄存器提取周期（ID）。
A 个 Regs［rs］；
B 个 Regs［rt］；

Imm • IR的符号扩展立即数字段；

操作—对该指令进行译码，并访问寄存器堆，以读取寄存器（rs 和rt为寄存器识别符）。
通用寄存器的输出被读入两个临时寄存器（A和 B）中，供之后的时钟周期使用。IR的低16
位也进行了符号扩展，存储在临时寄存器Imm 中，供下一个周期使用。

指令译码与寄存器读取是并行完成的，这一点之所以成为可能，是因为在MIPS 格式中，
这些字段放在固定位置。因为在所有 MIIPS 格式中，指令的立即数部分都位于同一位置，所以
在这一周期还会计算符号扩展立即数，以备在下一周期使用。

（3） 执行/实际地址周期（EX）。

ALLU 对前一周期准备的操作数进行操作，根据 MIIPS指令类型执行以下4种功能之一。

口 存储器引用：
ALUOutput f A + Inm；
操作—ALU将操作数相加，得到实际地址，并将结果放在寄存器 ALUOuput 中。
口寄存器-寄存器 ALU指令：
ALUOutput f A func B；
操作-ALU对寄存器A和寄存器 B 中的取值执行由功能代码指定的操作。结果放在
临时寄存器 ALUOutput中。
口 寄存器-立即数 ALU 指令：
ALUOutput f A op Imm：
操作—ALU对寄存器 A和寄存器Imm 中的值执行由操作代码指定的操作。结果放在
临时寄存器 ALUOutput 中。

口分支：
ALUOutput <- NPC + （Im <n 2）；
Cond 个 （A == 0）

操作 -ALU将 NPC加到 Imm 中的符号扩展立即数，将该立即数左移2位，得到一个
字偏移量，以计算分支目标的地址。检查已经在上一周期读取的寄存器 A，以确保该分
支是否被选中。由于我们仅考虑分支的一种形式（BEQZ），所以是与0进行对比。注意，
BEQZ 实际上是一个伪指令，它会转换为一个以 RO为操作数的 BEQ。为简单起见，我们这
里仅考虑这一种分支形式。

MIPS 的载人-存储体系结构意味着实际地址与执行周期可以合并到一个时钟周期中，因为
此时没有指令需要同时计算数据地址和指令目标地址，并对数据执行操作。各种形式的跳转指
令未包含在上述整数指令中，它们与分支相类似。

（4） 存储器访问/分支完成计算（MEM）。
对所有指令更新 PC:PC - NPC：
口存储器引用：

LMD 个 Mem ［ALUOutput］或
Mem［ALUOutput］ 个 B；
操作—在需要时访问存储器。如果指令为载入指令，则从存储器返回数据，将其放入
LMD（载人存储器数据）寄存器中；如果是存储指令，则将来自B寄存器的数据写人存
储器。无论是哪种情况，所使用的地址都是在上一周期计算得出并放在寄存器
ALUOutput 中的地址。

口分支：
if （cond）PC f ALUOutput
操作—如果该指令为分支指令，则用寄存器 ALUOutput 中的分支目标地址代替PC。

（5） 写回周期（WB）。
口 寄存器-寄存器 ALU指令：
Regs［rd］ 个 ALUOutput；
口寄存器-立即数 ALU 指令：
Regs［rt］ ALUOutput；

口 载人指令：
Regs［rt］ f LMD；

操作—无论结果来自存储器系统（在LMD中），还是 ALU（在 ALUOutput中），都将
其写到寄存器堆中；寄存器目标字段也在两个位置之一（rd或rt）之一，具体取决于实
际操作码。

图C-13显示了一条指令是如何流经数据路径的。在每个时钟周期结束时，在该时钟周期计
算并会在后面时钟周期用到的所有值（无论是供本条指令使用，还是供下一条指令使用）都被
写人存储设备中，可能是存储器、通用寄存器、PC或临时寄存器（即，LMD、Imm、A、B、
IR、NPC、ALUOutput或 Cond）。临时寄存器在一个指令的时钟周期之间保存值，而其他存储
元件则是状态的可视部分，在连续指令之同保存值。

尽管今天的所有处理器都是流水化的，但这种多周期实现方式合理地近似呈现了早些时候
是如何实现大多数处理器的。可以使用一种简单的有限状态机来实现一种遵循上述5周期结构
的控制。对于更复杂的处理器，可以使用微代码控制。在任何一种情况下，类似上述内容的指
令序列决定着控制结构。

在这种多周期实现中可以消除一些硬件冗余。例如，有两个 ALU：一个用于使PC递增，
一个用于实际地址和 ALU计算。由于不会在同一时钟周期用到它们，所以可以通过添加多工器
和共享同一 ALU来合并它们。同样，由于数据和指令访问发生在不同时钟周期内，所以指令和
数据可以存储在相同存储器中。

我们没有优化这一简单实现方式，而是保持图C-13所示设计方式，为流水化实现提供了更
好的基础。

图C-13 MIPS数据路径的实现允许每条指令在4或5个时钟周期内执行。尽管PC显示在指令提取使用
的数据路径部分、寄存器显示在指令译码/寄存器提取使用的数据路径部分，实际上这些功能单
元都是由一条指令读取和写人的。尽管这些功能单元显示在对其进行读取的周期内，实际上，
PC是在存储器访问时钟周期内写人，寄存器是在写回时钟周期内写入的。在这两种情况下，在
后续流水级中的写入是由多工器输出指示（在存储器访问或写回中），它将一个取值带回PC或
寄存器。流水线的大多数复杂性是由这些反向流动信号引入的，因为它们表明存在冒险的可能

作为本节所讨论多周期设计的一种替代方式，我们也可以将 CPU 实现为每条指令占用1个
长时钟周期。在这种情况下，由于一条指令之内的时钟周期之间不需要任何通信，所以将会删
除临时寄存器。每条指令都在1个长时钟周期内执行，在该时钟周期结束时将结果写人数据存
储器、寄存器或 PC。此类处理器的CPI为1。不过，这时的时钟周期大约等于多周期处理器时
钟周期的5倍，这是因为所有指令都需要遍历全部功能单元。设计人员从来不会使用这种单周
期实现方式，其原因有两个。第一，单周期实现对于大多数CPU的效率极低，因为对于不同指
令，它们的任务量会有合理的变动，从而时钟周期时间也会变动。第二，单周期实现需要重复
功能单元，而在多周期实现中，这些功能单元是可以共享的。不过，这种单周期数据路径可以
让我们说明流水化是如何从时钟周期时间的角度（而非CPI 的角度）来为处理器提供改进的。

\subsection{MIPS基本流水线}

和以前一样，只需要在每个时钟周期启动一个新指令，几乎不需要什么改变就可以对图C-13
的数据路径实现流水线。因为每个流水级在每个时钟周期都是活动状态，所以流水级中的所有操
作都必须在1个时钟周期内完成，任何操作组合都必须能够立即发生。此外，数据路径的流水化
要求必须将流水级之间传递的数值放在寄存器中。图C-14显示的 MIPS 流水线中包含了每个流
水级之间的适当寄存器，称为流水线寄存器或流水线锁存器。用这些寄存器相联的流水线名称
对其进行标记。图C-14的绘制方式清楚地显示了各级之间通过流水线寄存器的连接。

用于在一条指令的时钟周期之间保存临时值的所有寄存器都包含在这些流水线寄存器中。
指令寄存器（取）是正几寄存器的一部分，当它们用于提供寄存器名称时，对其字段进行标记。
这些流水线寄存器用于从一个流水级向下一个流水级传送数据和控制。在后续流水级上需要的所
有值都必须放在这样一个寄存器中，并从一个流水线寄存器中复制到下一个寄存器，直到不再需
要这些值为止。如果我们尝试仅在早期未流水化数据路径中使用临时寄存器，就有可能在完成所
有应用之前獲盖这些值。例如，寄存器操作数的字啟，用于在载人或 ALU操作中执行写人操作，
这一字段是从 MEM/WB 流水线寄存器而非 IF/ID 寄存器中提供的。这是因为我们希望一个载人
或 ALU操作写人该操作指定的寄存器，而不是该指令当前从 下传送到ID 的寄存器字段！这一
目标寄存器字段就是从一个流水线寄存器复制到下一个寄存器，直到在WB级用到它为止。

通过增加一组寄存器实现流水化的数据路径，每对流水线之间一个寄存。寄存器用于从一个
流水级问下一个流水级传送值和控制信息。我们也可以将PC看作一个流水线寄存器，它位于流
水线的『F级之前，指向每个流水级的一个流水线寄存器。回想一下，PC是一个边缘触发寄存器，
在时钟周期结束时对其进行写入；因此，在写人PC时不存在争用条件。PC 的多工器已被移动，
恰好在一个流水级（IF）中写人PC。如果我们没有移动它，那在发生分支时可能会出现冲突，
因为两条指令都会尝试将不同值写到PC中。大多数数据路径是由左向右流动，即从较早时间移
向较晚时间。从右向左流动的数据（携带着分支的写回信息和PC信息）增加了流水线的复杂性

任何一条指令在某一时刻恰好在一个流水级中处于活动状态；任何以指令名义执行的操作
都发生在一对流水线寄存器之间。因此，我们还可以通过以下方式来研究流水线的行为：查看
在不同指令类型下，各流水级上必须执行什么操作。表C-9展示了这一观点。流水线寄存器的
字段命名显示了数据在流水级之间的流动。注意，前两级的操作与当前指令类型无关。由于要
等到ID级结束时才会对指令进行译码，所以前两级的操作必须与当前指令无关。下F行为取决于
EX/MEM 中的指令是否为选中分支。如果是，则会在 IF结束时将 EX/MEM 中分支指令的分支
目标地址写人 PC中；如果不是，则写回递增后的 PC。（前面曾经说过，分支指令的这一效果
增加了流水线的复杂性，我们将在后面中进行讨论。）寄存器源操作数的固定位置编码对于在ID
期间提取寄存器是至关重要的。

流水級
表C-9 MIPS流水线每个流水线级上的事件
任意指令
\begin{verbatim}
    iD
    EX
    1F/ID.IR 个 Mem［PC］：
    IF/ID.NPC.PC 个（1千 （《EX/MEN. opcode == branch） & EX/MEM.cond） ｛EX/MEM.
    ALUOutput｝ else ｛PC+4｝）；
    TD/EX.A＜ RegS［AF/10.IR［rs）］： HD/EX.B -- Regs［IF/ID. IRIrt］］；
    D/EX.NPC f IF/ID.NPC；ID/EX.IR 个 1F/ID.IR
    D/EX.Imm 个 sign-extend（IF/ID.IR［irmediate field］）
    ALU指令
    载入或存储指令
    EX/MEM.IR 1 1D/EX.IR：
    EX/MEM.IR to ID/EX.IR
    EX/MEM.ALUOutput个
    EX/MEM.ALuOutputf
    ID/EX.A func ID/EX.B；
    10/EX.A + ID/EX.imm；
    或
    EX/MEM.ALuoutput1
    ID/EX.A op ID/EX.Imm：
    MEM/WB.IR ^EX/MEM.IR；
    MEM/WB.ALUOutpUt 1
    EX/MEM.ALUOutput；
    分支指令
    EX/MEM.ALUOutput个
    1D/EX.NPC+
    （ID/EX.Imm ss 2）；
    EX/MEM.cond 个
    （ID/EX.A == 0）；
    EX/MEM.B 4 ID/EX.B；
    MEM
    MEM/WB.IR ^ EX/MEM.IR：
    MEM/WB.LMD个
    Mem［EX/MEM.ALUOutput］：
    惑TEX/MEIM,ALUOutBut］
    EX/MEM.B：
    WB
    Regs ［MEM/WB.IR［rd］］个
    For 1oad only：
    MEM/wB.ALUOutput；
    或
    Regs［MEM/WB.IR［rt］］个
    MEM/WB.LMD：
    Regs ［MEM/WB.IR［rt］］
    MEM/WB.ALUOutput：
\end{verbatim}
•让我们回顾一下流水级中专门用于流水线组织的操作。在 IF 中，除了提取指令和计算新PC之外，我们还将递增后
的PC 存储到PC和流水线寄存器（NPC）中，供以后计算分支目标地址时使用。这个结构与圈C-14 中的组织方式相
同，在正使用两个来源之一更新PC。在ID中，我们提取寄存器，对IR（立即数字段）的低16位进行符号扩股，
并沿 IR和 NPC进行传送。在EX 期间执行 ALU运算或地址计算，沿 IR 和日寄存器进行传送（如果该指令海存储指
令）。如果该指合沟选中分支，我们还将cond的值设置为1。在MEM阶段，我们循环使用存储器，必要时写FC，
并传送在最后流水级中使用的值。最后，在 WB期间用ALU 输出值或載入值来更新寄存器字段。为简单起见，我们
总是将整个I从一级传送到下一级，实际上，在一条指令沿流水线流动时，财I的需要越来越少。

为了控制这一简单流水线，我们只需要决定如何设定图C-14数据路径中4个多工器的控制
方式。ALU级的2个多工器根据指令类型设定，由ID/EX 寄存器的IR字段规定。上面的 ALU
输入多工器根据该指令是否为分支来进行设定，下面的多工器根据该指令是寄存器-寄存器
ALU 操作还是任意其他类型的操作来设定。IF 级中的多工器选择是使用递增 PC的值，还是
EX/MEM.ALUOutput（分支目标）的值来写人PC。这个多工器由 EX/MEM.cond 字段控制。第
四个多工器由WB级的指令是载入指令还是 ALU指令来控制。除了这4个多工器之外，还需要
另外1个多工器，虽然未在图C-14中画出，但只要看一下 ALU操作的WB级就可以清楚地看
出是存在该选择器的。根据指令类型（是寄存器 寄存器 ALU，还是 ALU 立即数或载人），目
标寄存器字段为两个不同位置中的一个。因此，我们需要一个多工器来选择 MEM/WB 寄存器
中I的正确部分，以指定寄存器目标字段，假定该指令写人一个寄存器。

\subsection{实现MIPS流水线的控制}

将一条指令从指令译码级（ID）移人此流水线执行级（EX）的过程通常称为指令发射，已
经执行这一步骤的指令称为已发射。对于 MIPS 整数流水线，所有数据冒险都可以在该流水线
的ID阶段进行检查。如果存在数据冒险，该指令将在被发射之前停顿。与此类似，我们可以确
定在ID期间需要哪种转发，并设定适当的控制。如果在流水线早期检查互锁，除非整个处理器
停顿，否则硬件从来不需要挂起一条已经改变处理器状态的指令，从而降低了硬件的复杂性。
或者，我们可以在使用操作数的一个时钟周期之始（对于此流水线来说，为EX和MEM）检查
冒险或转发。为了说明这两种方法之间的区别，我们将展示如何通过在 ID 中进行检查来消除因
为载人指令所导致的写后读（RAW）冒险互锁（称为载人互锁），并说明如何实现指向ALUI输
人的转发路径。表C-10列出了我们必须处理的各种环境。

表C-10 流水线冒险通过对比相邻指令的目标与源检测硬件的情景
\begin{verbatim}
    情景
    没有相关性
    示例代码序列
    操作
    LD
    R1,45（R2）
    DADD R5,R6,R7
    由于后面紧随的三条指令不存在对R1的依赖性，所以不可能出现冒险
    DSUB R8,R6,R7
    OR
    R9,R6,R7
    相关性需要停顿
    LD
    R1,45（R2）
    DADD R5, R1,R7
    比较器在DADD开始EX之前检测DADD中的R1应用，并使DADD（及DSUB
    DSUB R8,R6,R7
    和OR）停顿
    OR
    R9,R6,R7
    通过转发克服相关性
    LD
    R1,45（R2）
    DADD R5,R6,R7
    比较器检测DSUB中对RI的应用，并将载入结果及时转发到ALU中，供
    DSUB R8, R1,R7
    DSUB开始EX
    OR
    R9,R6,R7
    循序访问的相关性
    LD
    R1,45（R2）
    DADD R5,R6,R7
    DSUB R8,R6,R7
    由于OR中对R1的读取发生在ID阶段的后半部分，而载人数据的写人发
    生在前半部分，所以不需要操作
    OR
    R9,RI,R7
\end{verbatim}
*这个表显示，对于跟在写指令后面的两条指令，只需要对其目标和源进行对比。在发生停顿时，一旦继续执行后，
流水线相关性与第三种情况类似。当然，涉及 RO的冒险是可以忽略的，这是因汐寄存器中总是包含零，而且上述测
试经扩展后可以完成这一任务。

接下来实现载人互锁。如果存在一个因为载入指令导致的RAW 冒险，当需要该载人数据
的指令存位于ID级时，该载入数据将位于EX级。因此，我们可以用一个很小的表来描述所有
可能存在的情景，可以直接将其转换为实现方式。表C-11显示了当使用载入结果的指令位于ID
级时，检测到负载互锁的逻辑。

表C-11 用于检测一条指令的ID级中是否需要载入互锁的逻辑
\begin{verbatim}
    ID/EX的操作码字段（ID/EX.IRo.5）
    IF/ID的操作码字段（IF/ID.IRg.5）
    匹配操作数字段
    载人
    寄存器-寄存器ALU
    ID/EX.IRCrt］== IF/ID.IRCrs］
    载人
    寄存器-寄存器ALU
    ID/EX.IR［rt］ == IF/ID.IR［rt］
    载人
    载人、存储、AL.U立即数或分支
    ID/EX.IRCrt］ -= iF/ID.IR［rs］
\end{verbatim}
*表中第1行和第2行测试載入目标寄存器是否为 ID 中寄存器一寄存翠操作的源寄存露之一。表中第3行判断栽入目
标寄存器是否沟載入或存储有限地址、ALU 立即数或分支测试的源。请记住，IF/D 寄存器保存着 ID 中指令的状态，
它可能会用到載入结果，而 ID/EX保存着 EX 中指令的状态，它是藏入指令。

一旦检测到冒险，控制单元必须插人流水线停顿，并防止 下F和ID 级中的指令继续前进。
前面曾经看到，所以控制信息都承载于流水线寄存器中。（仅承载指令就足够了，因为所有控制
都是由其派生而来的。）因此，在检测冒险时，只需要将 ID/EX 流水线寄存器的控制部分改为
全0，它正好是一个空操作（一个不做任何事情的指令，比如 DADD RO,RO，RO）。此外，我们只
需循环使用 IF/D 寄存器中的内容，以保存被停顿的指令。在具有更复杂冒险的流水线中，这
些思想同样适用：对比一组流水线寄存器，并转换为空操作，以防止错误执行。

转发逻辑的实现尽管需要考虑更多种情况，但大体类似。要实现转发逻辑，关键是要注意
到流水线寄存器中既包含了要转发的数据，也包含了源、目标寄存器字段。所有转发在逻辑上
都是从 ALU 或数据存储器的输出到ALU输人、数据存储器输人或零检测单元。因此，我们可
以对比 EX/MEM 和 MEM/WB级中所包含IR 的目标寄存器与 ID/EX 和 EX/MEM 寄存器中所包
含IR 的源寄存器，以此来实现转发。表C-12显示了这些对比，以及当转发结果的目的地是EX
中当前指令的 ALU输人时，可能执行的转发操作。

表C-12
可以从ALU结果（EX/MEM中或MEM/WB中）或从MEM/WB中的载入结果向两个ALU输入转发
数据（供EX中的指令使用）
\begin{verbatim}
    包含源指令的
    源指令的
    包含目标指令的
    目标揖令的操作码
    流水线寄存髒
    操作码
    流水线寄存器
    EX/MEM
    寄存器-
    D/EX
    转发结果的目
    的地
    顶部ALU输人
    寄存嬲ALU
    比较（若相等，则
    转发）
    EX/MEM.IRLrd］
    ==ID/EX.IRLr$］
    EX/MEM
    DD/EX
    寄存器-寄存嬲ALU、
    ALU立即数、载人、
    存储、分支
    寄存器-寄存器ALU
    底部ALU输入
    MEM/WB
    寄存器-
    寄存器ALU
    寄存器-
    寄存器ALU
    ID/X
    EX/MEM.IR［rd］
    ==TD/EX.IRLrt］
    MEM/WB.IRCrd］
    --ID/EX.IR［rs］
    MEM/WB
    DD/EX
    寄存器-寄存器ALU、
    ALU立即数、载人、
    存储、分支
    寄存器-寄存器ALU
    顶部ALU输入
    EX/MEM
    寄存器-
    寄存器ALU
    ALU立即数
    底部ALU输入
    TEX
    MEM/WB.IR［rd］
    --ID/EX.IR［rt］
    EX/MEM.IRCrt］
    =eID/EX.IR［rs］
    EX/MEM
    MEM/WB
    ALU立即数
    ALU立即数
    ID/EX
    ID/EX
    LD/EX
    寄存器-寄存器ALU、
    ALU立即数、载入、
    存储、分支
    寄存器-寄存器ALU
    寄存器-寄存器ALU、
    ALU立即数、载人、
    存储、分支
    寄存器-寄存器ALU
    顶部ALU输人
    底部ALU输人
    顶部ALU输人
    EX/MEM.IR［rt］
    ==ID/EX.IRLrt］
    MEM/WB.IRIrt］
    ==ID/EX.IRLrs］
    MEM/WB
    MEM/WB
    ALU立即数
    载人
    底部ALU输人
    TD/EX
    寄存器-寄存器ALU、
    ALU立即数、载入、
    存储，分支
    寄存器-寄存器ALU
    顶部ALU输人
    MEM/WB.IRCrt］
    ==ID/EX.IR［rt］
    MEM/WB.IR［rt］
    ==1D/EX.IRCrs］
    MEM/WB
    载人
    ID/EX
    底部ALU输人
    MEM/WB.IR［rt］
    ==ID/EX.IR［rt］
\end{verbatim}
*为了判断是否应当发生特发操作，一共需要10次不同比较。顶郵和底部的 ALU 输入分別指代与第一、第二 ALU源
操作数相时应的输入，如图C-13及圈C-15中所示。请记住，EX中目标指令的流水线锁存器是 ID/EX，而源值来自
EX/MEM或 MEM/WE的 ALUOutput部分，或者 MEM/WB的LMD部分。有一个复杂问题未能通过这一逻辑解决：
处理多条向相同寄存器进行写入的指令。例如，在代码序列 \verb|DADD RI.R2.R3: DADDI RI, RL， #2: DSUB R4. R3. RI| 期间，
该逻辑必须确保 DSUB指令使用的是 DADDI 指令的数据，而不是 DADD指令的结果。为了处理这一情景，可以扩展上述
逻拜：仅在未对相同输入转发来自 EX/MEM 的结果时，才检测来自 MEM/WB 的转发。由于 DADDI 结果将位于 EX/MEM
中，所以将转发该结果，而不是 MIEM/WB 中的 DADD 结果。

除了在需要启用转发路径时必须确定的比较器和组合逻辑之外，还必须扩大ALU输入端的
多工器，并添加一些连接，这些连接源于转发结果所用的流水线寄存器。图C-15给出了流水化
数据路径的相关段，其中添加了所需要的多工器和连接。

图C-15
向ALU转发结果需要在每个 ALU多工器上另外增加三个输入，增加三条指向这些新输入的路径。
这些路径对应于以下三者的一个旁路：（1）EX 结束时的ALU输出；（2）MIEM级结束时的ALU输
出；（3）MEM级结束时中的存储器输出

对于 MIPS，冒险检测和转发硬件是相当简单的；我们将会看到，当为处理浮点数而对这
一流水线进行扩展时，事情多少会变得复杂一些。在此之前，需要处理分支。

\subsection{处理流水线中的分支}
在 MIPS 中，分支（BEQ 和 BNE）需要检测一个寄存器，看其是否等于另一个寄存器（该寄
存器可能为 RO）。如果仅考虑 BEQZ 和 BNEZ 的情景（它们需要零检测），那有可能通过将零检测
移到周期内部，在ID 周期结束时完成此判断。为了充分利用尽早判断出该分支是否命中的优势，
都必须尽早计算 PC（无论命中还是未命中）。在ID期间计算分支目标地址需要增加一个加法器，
因为前面一直用于实现此功能的主 ALU在EX之前是不可用的。图C-16给出了修订后的流水化
数据路径。通过增加独立的加法器，并在ID 期间作出分支判断，分支仅需要停顿1个时钟周期。
尽管这样将分支延迟缩减为1个周期，但这意味着如果一个 ALU 指令后面跟有一个依赖该措令
结果的分支，那就会招致数据冒险停顿。表C-13显示了表C-9中修订后的流水线表的分支部分。

在一些处理器中，分支冒险的代价（以时钟周期为单位）比我们这里的例子中更昂贵，因
为评估分支条件和计算目的地的时间可能更长一些。例如，拥有独立译码和寄存器提取级的处
理器可能存在分支延迟（控制冒险的长度），其长度至少为1个时钟周期。除非经过处理，否则
分支延迟会转变为分支代价。许多实现更复杂指令集的较旧 CPU，其分支延迟为4个时钟周期，
甚至更长一些，而大型深度流水化处理器的分支代价经常为6或7个时钟周期。一般来说，流
水线越深，以时钟周期度量的分支代价就越糟。当然，较长分支代价的相对性能性能影响取决
于处理器的总CPI。低CPI 的处理器可以承受更昂贵的分支，这是因为分支导致处理器性能下
降的百分比较低。

ID/EX
IF/ID
EX/MEM
MEM/WB
-零？
指令
存储器
IR
IR6.10
IRH.1S
MEM/WE.1R 寄存器
U
X
数据
寄仔器
L/符号2
扩展

图 C-16 将零检测和分支目标计算移到流水线的ID级中，可以缩减因为分支冒险导致的停顿。注意，我
们已经进行了两处重要改变，每个改变消除了分支指令的三周期停顿之一。第一处变化是将分支
目标地址计算和分支条件判断移到 TD周期。第二处变化是在IF阶段写人指令的PC，或者使用
在ID阶段计算的分支目标地址，或者使用在IF期间计算的递增PC。在对比中，图C-14从EX/MEM
寄存器中获取分支目标地址，并在 MEM 时钟周期内写入结果。在图C-14中曾经提到，可以将
PC看作流水线寄存器（例如，作为ID/IF 的一部分），会在每个 下F周期结束时向其中写人下一条
指令的地址

流水级
ID
表C-13 这一经过修订的流水线结构是以表C-9中的原流水线为基础的
分支指令
\begin{verbatim}
    IF/ID.IR f Mem［PC］；
    ［F/ID.NPC.PC 个（if（（TF/ID.opcode == branch） & （Regs IF/LD.1R：
    2p o））｛IF/ID.NPC + sign-extended （IF/ID.IR ［imnediate fleld］ << 2） else （PC + 4｝）；
    ID/EX.A <- Regs［IF/ID.IR6..10］：ID/EX.B Regs［IF/ID.IR11..150；
    ID/EX.IR f- IF/ID.IR；
    1D/EX.Imm 个 （IF/ID.IR16）26##IF/ID.IR16..31
    C-42
    EX
    MEM
    WB
\end{verbatim}
*它使用一个独立的加法器（和圈C-16一样），在ID期间计算分支目标地址。新操作或发生变化的操作以思体标出。
由于分支目标地址加法是在 IID 期间发生的，所以针财所有指令都会经过这一步骤；分支条件（RgS［IF/ID.IR6..10］
op 0）也对所有指令有效。是选择顺序 PC还是分支目标PC，仍然是在 T期间决定的，但它现在仅使用来自 四D級
的取值，这些值与上一条指令设定的值相对应。这一改变使分支代价降低两个周期，一个周期是因力提前计算分支
目标和条件，一个周期是因在岡一时鈡周期内控制 PC选择，而没有推至下一周期。由于 cond 的值被设置*0，
所以除非 ID 中的指令为选中分支，则诚处理器必须在ID结来之前对指令进行译码。因沟讓分支在ID 结来时完成，
所以分支指令没有用到 EX、MEM和 WB级。对于偏移量长于分支的跳转，还会进一步增加复杂性。我们可以增加
一个加法器，将IR 中低25位左移2位后的值与 PC相加，以应对上述复杂性。

\section{妨碍流水线实现的难题}

我们已经理解了如何检测和解决冒险问题，现在就可以处理一些前面一直在回避的复杂问
题。本节的第一部分考虑一些异常情景带来的挑战：指令的执行顺序发生意外变化。在本节的
第二部分，我们将讨论一些由于不同指令集带来的挑战。

\subsection{处理异常}
异常情景在流水化CPU 中更难处理：由于指令的重叠，更难以判断一条指令是否能安全地
改变CPU的状态。在流水化 CPU 中，指令是一段一段地执行，在几个时钟周期内不会完成。
不幸的是，流水线中的其他指令可能会引发一些异常，强制CPU在流水线中的指令尚未完成时
中止执行。在详细讨论这些问题及其解决方案之前，需要了解可能出现哪些类型的情景，为它
们提供支持有哪些体系结构方面的需求。

\subsubsection{异常的类型与需求}
对于一些改变指令正常执行顺序的异常情景，在不同 CPU 中会采用不同的术语来进行描
述。人们会使用中断、错误和异常等词，但具体用法并不一致。我们用异常一词来涵盖包括下
列内容的所有此类机制：
\begin{itemize}
    \item 1/O设备需求
    \item 从用户程序调用操作系统服务
    \item 跟踪指令执行
    \item 断点（程序员请求的中断）
    \item 整数算术溢出
    \item 浮点算术异常
    \item 页面错误（不在主存储器中）
    \item（在需要对齐时）存储器访间未对齐
    \item 违反存储器保护规则
    \item 使用未定义或未实现的指令
    \item 硬件故障
    \item 电源故障
\end{itemize}
当我们希望引用这些异常中的某一具体类别时，将使用一个较长的名称，比如1/O 中断、
浮点异常或页面错误。表C-14显示了上述常见异常事件的各种不同名称。

\begin{verbatim}
    表C-14 4种不同体系结构对常见异常来用的名称不同
    异常事件
    I/O设备请求
    从用户程序调用
    操作系统服务
    跟踪指令异常
    断点
    整型算术上溢或
    下溢、FP陷阱
    IBM 360
    VAX
    Motorola 680x0
    输入/输出中断
    设备中断
    异常（LO至L7自动向量）
    管理员调用中断
    异常（改变模式管理
    异常（未实现的指令）
    Intel 80x86
    向量化中断
    中断（INT中断）
    员陷阱）
    -在Macintosh上
    不适用
    不适用
    程序中断（上溢或
    下溢异常）
    异常（跟踪错误）
    异常（跟踪）
    中断（美淼陷阱）
    异常（断点错误）
    异常（非法指令或断点）
    中断（取
    陷阱）
    异常（整型上溢陷阱 异常（浮点协处理器错误）
    中断（溢出陷味或
    或浮点下溢错误）
    数学单元异
    C-43
    ©44
    486
    附录C 流水线：基础与中级概念
    异棠事件
    页面错误（不在
    主存储器中）
    未对齐存储器访问
    违反存储器保护规则
    IBM 360
    不适用（仅370中）
    VAX
    Motorola 680×0
    异常（转移无效错误） 异常（存储器管理
    （续）
    Intel 80×86
    •中断（页面错误）
    单元错误）
    程序中断（规范异常）
    程序中断（保护异常）
    不适用
    异常（地址错误）
    异常（违犯访问控制
    异常（总线错误）
    不透用
    中断（保护异常）
    错误）
    使用未定义指令
    程序中断（操作异常）
    异常（操作码权限/ 异常（非法指令或
    中断（无效操作码）
    保留错误）
    断点/未实现的指令）
    硬件故障
    机器检查中断
    异常（机器检查中止）异常（总线错误）
    不适用
    电源故障
    机器检查中断
    紧急中断
    不适用
    不可屏蔽中断
\end{verbatim}

*IBM 360 和80x86上的每个事件都称为中断，而680x0 中的每个事件称为异常。VAX 将事件划分为中断或异常。在
VAX 中断中使用了设备、软件和紧急等修饰词语，而 VAX 身常則细分为故障、陷阱和中止。

尽管我们使用异常一词来涵盖所有这些事件，但各种事件都有自己的重要特性，决定了硬
件中需要采取什么操作。关于异常的需求，可以从五个半独立的方面进行描述。

\begin{enumerate}
    \item 同步与异步—如果每次以相同数据和存储器分配执行程序时，事件都在同一位置发
    生，那事件就是同步的。由于硬件故障等常，可能会由CPU 和存储器外部的设备导致异步事
    件。异步事件通常可以在完成当前指令后处理，使其处理变得更容易一些。
    
    \item 用户请求与强制——如果用户任务直接请求某一事件，那它就是用户请求事件。在某种
    意义上，用户请求的异常不是真正的异常，因为它们是可预测的。但是，由于对这些用户请求
    事件使用了用于存储和恢复状态的相同机制，所以也将它们看作异常。因为对于触发这一异常
    的指令来说，其唯一功能就是引发该异常，所以用户请求异常总是可以在完成该指令之后加以
    处理。强制异常是由某一不受用户程序控制的硬件事件导致的。强制异常不可预测，所以更难
    以实现。
    
    \item 用户可屏蔽与用户不可屏蔽—如果一个事件可以借由用户任务来屏蔽或禁用，那它就
    是用户可屏蔽的。这一屏蔽只是控制硬件是否对异常进行回应。
    
    \item 指令内部与指令之间—这种分类取决于妨碍指令完成的事件是发生在执行过程中间
    （无论多短），还是被看作是发生在指令之间。发生在指令内部的异常通常是同步的，因为就是
    这条指令触发了异常。在指令内部发生的异常实现起来要难于指令之间的异常，因为该指令必
    须被停止、重新启动。发生在指令内部的异步异常是因为灾难性情景（例如，硬件故障）出现
    的，所以总会导致程序终止。
    
    \item 恢复与终止——如果程序的执行总是在中断之后停止，那它就是終止事件。如果程序的
    执行在中断之后继续，那它就是恢复事件。终止执行的异常实现起来更容易一些，因为 CPU不
    需要在处理异常之后重启同一程序。
\end{enumerate}

表C-15根据这 5个类别对表C-14中的示例进行了划分。难点在于实现指令之间发生的中
断，对于这种中断必须恢复指令的执行。此类异常的实现要求必须调用另一个程序，以保存所
执行程序的状态、解决导致异常的原因，然后恢复程序的状态，之后才再次尝试导致该异常的
指令。对正在执行的程序来说，这个过程事实上必须是不可见的。如果流水线使处理器能够在
不影响程序执行的前提下处理异常、保存状态并重新启动，那就说流水线或处理器是可重新启
动的。早期的超级计算机和微处理器通常缺少这一特性，但今天的几乎所有处理器都支持这一
特性，至少整数流水线是这样的，因为虚拟存储器的实现需要这一特性（见第2章）。

表C-15 用5个类别来确定表C-14所示不同异常类型所需要的操作
\begin{verbatim}
    异常类型
    同步与异步
    用户请求
    用户可屏蔽与
    指令内部与
    与强制
    不可屏蔽
    指令之间
    VO设备请求
    异步
    强制
    不可屏蔽
    之间
    调用操作系统
    同步
    用户请求
    不可屏蔽
    之间
    跟踪指令执行
    同步
    用户请求
    用户可屏蔽
    断点
    同步
    用户请求
    用户可屏献
    整型算术溢出
    同步
    用户可屏蔽
    浮点算术上溢或下溢
    同步
    用户可屏蔽
    页面错误
    同步
    不可屏蔽
    非对齐存储器访问
    同步
    用户可屏蔽
    违反存储器保护规则
    同步
    不可屏蔽
    使用未定义指令
    同步
    强制
    不可屏蔽
    内部
    硬件故障
    异步
    强制
    不可屏蔽
    内部
    电源故障
    异步
    强制
    不可屏蔽
    内部
    恢复与终止
    恢复
    恢复
    恢复
    恢复
    恢复
    恢复
    恢复
    恢复
    恢复
    終止
    終止
    終止
\end{verbatim}
*必须允许恢复的异步被标记沟恢复，尽管软件可能选择终止程序。发生在指令内部的可恢复、岡步、强制异常是最
难实现的。我们可能希望违反存储器保护访问的异常总是导致终止；但是，现代操作系统使用存储器保护来检测事
件，比如首次尝试使用一个页面，或者首次尝试写入一个页面。因此，CPU应当能够在此类异常之后恢复执行。

\subsubsection{停止和恢复执行}
和在非流水化实现中一样，最困难的异步有两种特征：（1）发生在指令内部（即，在指令热
行过程期间发生，与EX或 MEM 流水级相对应）：（2）必须可以重新启动。比如，在MIIPS 流水
线中，由数据提取导致的虚拟存储器页面错误只可能发生在该指令 MEM 级的某一时间之后。
在出现该错误时，会有其他几条指令正在执行。页面错误必须是可重新启动的，需要另一进程
（比如操作系统）的干预。因此，必须能够安全关闭流水线并保存其状态，使指令能够以正确状
态重新启动。重启过程的实现通常是通过保存待重启指令的 PC来实现的。如果被重启的指令
不是分支，则继续提取依次排在后面的指令，以正常方式开始执行。如果被重启的指令为分支
指令，则重新计算分支条件，根据计算结果提取目标指令或直通指令。在发生异步时，流水线
控制可以采取以下步骤安全地保存流水线状态。

\begin{enumerate}
    \item 在下一个 正向流水线中强制插入一个陷阱指令。
    \item 在选中该陷阱指令之前，禁止错误指令的所有写入操作，禁止流水线中后续所有指令的
    写人操作。可以通过以下方式来实现：从生成该异常的指令开始（不包括该指令之前的指令），
    将流水线中所有指令的流水线锁存置零。这样可以禁止在处理异常之前对未完成指令的状态进
    行任何更改。
    \item 在操作系统的异常处理例程接收控制权之后，它会立即保存故障指令的PC。后面从异
    常返回时会用到这个值。
\end{enumerate}

当我们使用延迟分支时，如上一节所述，由于流水线中的指令可能不是顺序相关的，所以
仅用一个 PC不再可能重建处理器的状态。因此，我们需要保存和恢复的PC数目等于分支延迟
的长度加1。这一步骤是在上述第（3）步完成的。

在处理异常之后，特殊指令通过重新加载PC并重启指令流（在MIPS 中使用指令 RFE）从
异常中返回处理器。如果流水线可以停止，使紧临错误指令之前的指令能够完成，使其之后的
指令可以从头重新启动，那就说该流水线拥有精确异常。在理想情况下，错误指令可能还没有
改变状态，要正确地处理一些异常，要求错误指令不产生任何影响。对于其他异常，比如浮点
异常，某些处理器上的错误指令会首先写人其结果，然后才能处理异常。在此种情况下，即使
目标位置与源操作数之一的目标位置相同，也必须准备硬件来提取源操作数。因为浮点操作可
能持续许多个周期，所以其他某一指令非常可能已经写人了这些源操作数（在下一节将会看到，
浮点操作经常是乱序完成的）。为了克服这一问题，最近的许多高性能 CPU 引人了两种操作模
式。一种模式有精确异常，另一种（快速或性能模式）则没有精确异常。当然，精确异常模式
要慢一些，因为它允许浮点指令之间的重叠较少。在一些高性館 CPU（包括 Alpha21064、Power2
和 MIPS R8000）中，精确模式通常要慢得多（相差10倍以上），因此仅能用于代码调试。

在许多系统中，对精确异常的支持是必备功能，而在其他一些系统中，它“只是”存在一
定的价值，因为它可以简化操作系统接口。至少，任何需要分页或TEEE 算术陷阱处理程序的
处理器都必须使其异常为精确异常，可以用硬件实现，也可以辅以一定的软件支持。对于警数
流水线，创建精确异常的任务比较简单，支持虚拟内存是存储器引用支持精确异常的极大动力。
在实践中，这些理由已经让设计师和架构师总是为整数流水线提供精确异常。本节将介绍如何
为MIPS整数流水线实现精确异常。我们将在C.5 节介绍一些技术，用来应对浮点流水线中出
现的更复杂挑战。

\subsubsection{MIPS 中的异常}
表C-16显示了 MIPS流水级，以及每一级中可能发生哪些问题异常。采用流水化时，由于
有多条指令同时执行，所以在同一时钟周期中可能出现多个异常。例如，考虑如下指令序列：
\begin{verbatim}
    LD
    ID
    EX
    MEM
    WB
    DADD
    IF
    EX
    MEM
    WB
\end{verbatim}
这一对指令可能同时导致数据页面错误和算术异常，这是因为 ID 处于 MEM 级，而 DADD
位于 EX级。要处理这一情景，可以先处理数据页面错误然后再重启执行过程。第二个异常将
再次发生（如果软件正确，第一个异常将不再发生），这样，在发生第二个异常时，就可以单独
对其进行处理。

\begin{verbatim}
    表C-16
    流水级
    IF
    ID
    EX
    可能在MIPS流水线中发生的异常
    所发生的问题异常
    指令提取时发生页面错误、非对齐存储器访问、违反存储器保护规则
    未定义或非法操作码
    箅术异常
    MEM
    数据提取时发生页面错误、非对齐存储器访问、违反存储器保护规则
    WB
\end{verbatim}
*由指今或数据存储器访问产生的异常可能占到8种情景的6种。

现实中的情景并不像这个简单例子中那样明了。异常可能乱序发生；也就是说，可能在一
条指令先行产生异常之后，排在前面的指令才产生异常。再次考虑上述序列，LD后面跟着 DADD。
当LD处于 下F时可能产生数据页面错误，而DADD指令位于 IF时可能会产生指令页面错误。指令
页面错误尽管由后一指令导致，但实际上它将会首先发生。

由于我们正在实现精确异常，所以流水线需要首先处理由LD指令导致的异常。为了解释如
何实现这一过程，我们将位于LD指令位置的指令称为i，将位于 DADD 指令位置的指令称计1。
流水线不能在发生异常时直接处理它，因为这样会导致这些异常的发生顺序不同于非流水化顺
序。硬件会将一条给定指令产生的所有异常都记录在一个与该措令相关联的状态向量中。这个
异常状态向量将一直随该指令向流水线下方移动。一旦在异常状态向量中设定了异常指示，则
关闭任何可能导致数据值写人（包括寄存器写人和存储器写人）的控制信号。由于存储指令可
能在 MEM期间导致异常，所以硬件必须准备好在存储指令产生异常时阻止其完成。

当一条指令进入 WB时（或者将要离开 MEM时），将检查异步状态向量。如果发现存在任
何异常，则按照它们在非流水化处理器中的发生顺序进行处理—首先处理与最早指令相对应
的异常（通常位于该指令的最早流水级）。这样可以保证：指令：引发的所有异常将优先得到处
理，早于指令计1引发的所有异常。当然，任何在较早流水级中以指令i名义采取的操作都是无
效的，但由于对寄存器堆和存储器的写人操作都被禁用，所以还没有改变任何状态。在C.5节
将会看到，要浮点运算维护这一精确模型要困难得多。

一些处理器拥有功能更强大、运行时间更长的指令，下一小节将介绍在此类处理器的流水
线中实现异常时存在的问题。

\subsection{指令集的复杂性}
所有 MIPS指令的结果都不会超过1个，我们的MIPS流水线仅在指令执行结束时写人结果。
在保证一条指令完成时，称为已提交。在 MIPS 整数流水线中，当所有指令到达MEM级的末
尾（或者WB 的开头），而且没有指令在该级之前更新状态，则说这些措令己提交。因此，精确
异常非常简单。一些处理器的指令会在指令执行中间更改状态，更改状态时，该指令及其之前
的指令可能还未完成。例如，IA-32体系结构中的自动递增寻址模式可以在一条指令的执行过程
中更新寄存器。在这种情况下，如果该指令由于异常而终止，则会使处理器状态发生变化。尽
管我们知道哪些指令会导致异常，但由于该指令处于半完成状态，所以在未添加硬件支持的情
况下，异常是不准确的。在这样一个非精确异常之后重启指令流是有难度的。我们也可以避免
在指令提交之前更新状态，但这种做法的难度很大，或者成本很高，这是因为可能会用到经过
更新的状态：考虑一条 VAX指令，它多次递增同一寄存器。为了保持精确异常模型，大多数拥
有此类指令的处理器能够在提交指令之间回退所做的状态更改。如果发生异常，处理器将使用
这一功能将处理器状态还原为开始中断指令之前的值。在下一节，我们将会看到一种功能更
强大的 MIPS 浮点流水线可能会引入类似问题，在C.7 节介绍了一些用于完成复杂异常处理的
技术。

一些在执行期间更新存储器状态的指令也会增加难度，比如 VAX或IBM 360上的字符串
复制操作（参见附录K）。为中断和重启这些指令，规定这些指令使用通用寄存器作为工作寄存
器。因此，部分完成指令的状态总是位于寄存器中，这些寄存器在发生异常时被保存，在异常
之后恢复，使指令可以继续执行。在VAX 中，有另外一个状态位记录指令何时开始更新存储器
状态，从而在重启流水线时，CPU 知道是从头开始重启指令，还是从指令的中间开始。IA-32
字符串指令也使用寄存器作为工作存储器，这样，在保存和恢复寄存器时，也会保存和恢复这
些指令的状态。

奇数个状态位可能会导致另外一组不同的难题：可能另外增加流水线冒险，可能需要额外
的硬件来进行保存和恢复。条件代码就是这种情况的一个好例子。许多处理器隐式设定条件码，
将其作为指令的一部分。这种方法具有一定的优势，因为条件码将条件的判断与实际分支分离开
来。但是，在调度条件代码设定与分支之间的流水线延迟时，由于大多数指令都会设定条件码，
而且不能在条件判定与分支之间的延迟时隙中使用，所以隐式设定条件可能会增加调度难度。

另外，在具有条件码的处理器中，处理器必须判断何时确定分支条件。这就需要找出分支
之前最后一次设置条件代码是在什么时候。在大多数隐式设定条件码的处理器中，其实现方式
是推迟分支条件判断，直到先前的所有指令都有机会设定条件代码为止。

当然，显式设定条件码的体系结构允许在条件测量与待调度分支之间插人延迟；但是，流
水线控制必须跟踪最后一条设定条件码的指令，以便知道何时确定分支条件。实际上，必须将
条件码当作一个操作数对待，需要进行RAW 冒险检测，就像 MIPS 必须对寄存器进行检测一样。

流水线中最后一个棘手领域是多周期操作。假定我们尝试实现下面这样一个VAX 指令序列
的流水化：
\begin{verbatim}
    MOVL
    R1,R2
    ；在寄存器之间稻动
    ADDL3
    42（R1），56（R1）+，@（R1）
    ；对存储嚣位置求和
    SUBL2
    R2,R3
    ；减去寄存翠
    MOVC3
    ©（R1）［R2］，74（R2），R3
    i移动字符串
\end{verbatim}
这些指令所需要的时钟周期数有很大差别，低至1个，高至数百个。它们所需要的数据存储器
访问数也不一定，有的不需要访问数据存储器，有的可能需要数百次访问。数据冒险非常复杂，
在指令之间和指令内部均会发生。一种简单的解决方案是让所有指令的执行周期数相同，但这
种解决方案是不可接受的，因为它会引入数目庞大的冒险和旁通条件，形成一条极长的流水线。
在指令级实现 VAX的流水化是很困难的，但VAX 8800设计师找到了一种非常聪明的解决方案。
他们实现了微指令执行的流水化。微指令就是一种简单指令，在序列中用于实现更复杂的指令
集。由于微指令都很简单（它们看起来与 MIPS非常相似），所以流水线控制要容易得多。从1995
年开始，所有 Intel IA-32 微处理器都使用这一策略将IA-32指令转换为微操作，然后再实现微
操作的流水化。

作为对比，载人-存储处理器拥有一些筒单操作，完成的工作数量相似，更容易实现流水化。
如果架构师认识到指令集设计与流水化之间的关系，他们就可以设计出能够高效流水化的设计
体系结构。在下一节将会看到 MIPS 流水线如何处理长时间运行的指令，特别是浮点操作。
许多年以来，人们一直认为指令集与实现之间的互动非常少，在设计指令集时，实现问题
不是主要关注点。20世纪80年代，人们认识到指令集的复杂性会增加流水化的难度、降低流
水化的效率。20世纪90年代，所有公司都转向更简单的指令集，目标在于降低积极实现的复
杂性。

\section{扩展 MIPS 流水线，以处理多周期操作}

我们现在希望研究如何扩展 MIIPS 流水线，以处理浮点运算。这一节的重点是介绍基本方
法和各种候选设计方案，最后是对一种 MIIPS 浮点流水线的性能测量。

要求所有 MIPS 浮点运算都在1个时钟周期内完成是不太现实的，甚至在2个时钟周期内
也有很大难度。这样做就意味着要么接受缓慢的时钟，要么在浮点单元中使用大量逻辑，或者
同时接受两者。而实际情况是，浮点流水线将会允许更长的操作延迟。如果我们设想浮点指令
拥有与整数指令相同的流水线，那就容易理解了，当然流水线中会有两处重要改变。第一，为
了完成操作，EX 周期可能要根据需要重复多次，不同操作的重复次数可能不同。第二，可能存
在多个浮点功能单元。如果待发射指令会导致它所用功能单元的结构性冒险，或者导致数据冒
险，将会出现停顿。

针对本节，我们假定MIPS 实现中有以下4个独立的功能单元。
\begin{enumerate}
    \item 主整数单元，处理载人和存储、整型 ALU操作，还有分支。
    \item 浮点与整数乘法器。
    \item 浮点加法器，处理浮点加、减和转换。
    \item 浮点和整型除法器。
\end{enumerate}

如果我们还假定这些功能单元的执行级没有实现流水化，那么图C-17给出了最终的流水线
结构。由于EX未被流水化，所以在前一指令离开EX之前，不会发射任何其他使用这一功能单
元的指令。另外，如果一条指令不能进入EX级，该指令之后的整个流水线都会被停顿。

增加了三个未流水化浮点功能单元的MIPS流水线。因为每个时钟周期仅发射一条措令，所以
所有指令都会经历整型运算的标准流水线。只是浮点运算在到达EX级时会循环。在它们完成
EX级之后，则进入MEM和 WB 级，以完成执行

事实上，中间结果可能不会像图C-17所建议的那样围绕EX单元循环；而是在EX 流水级
拥有一些大于1的时钟延迟。我们可以推广如图C-17所示的浮点流水线结构，以允许实现某些
级的流水化，并允许多个操作同时进行。为了描述这样一个流水线，我们必须定义功能单元的
延迟以及启动间隔（或称重复间隔）。我们采用之前的相同方式来定义延迟：生成结果的指令与
使用结果的指令之间的周期数。起始间隔或重复间隔是指在发出两个给定类型的操作之间必须
间隔的周期数。例如，我们将使用如表C-17所示的延迟和启动间隔。

根据这一延迟定义，整型ALU 运算的延迟为0，因为其结果可以在下一时钟周期使用；载
入指令的延迟为1，因为这些结果可以相隔一个周期之后使用。由于大多数操作都会在EX的开
头使用其操作数，所以延迟通常是指EX之后的级数（一条指令在EX生成结果），例如，ALU
运算之后有0个流水级，而载入指令则有1级。一个重要的例外是存储指令，它会在一个周期
之后使用被存储的值。因此，存储指令的延迟是针对被存储的值而言，而不是针对基址寄存器，
所以少1个周期。流水线延迟基本上等于执行流水线深度减去1个时钟周期，而流水线深度等
于从EX级到生成结果的流水级之间的级数。因此，对于上面的示例流水线，浮点加法中的级
数为4，而浮点乘法的级数为7。为了获得更高的时钟频率，设计师需要降低每个流水级中的逻
辑级数，而这样会增大更复杂操作所需要的流水级数。高时钟频率的代价是延长了操作的延迟。

表C-17 功能单元的延迟和启动间隔
\begin{verbatim}
    功能单元
    延
    迟
    整数ALU
    数据存储器（整数和浮点载人）
    浮点加
    浮点乘（也是整数乘）
    浮点除（也是整数除）
    0
    i
    3
    6
    24
    启动间隔
    1
    1
    1
    1
    25
\end{verbatim}
表C-17中的示例流水线结构允许多达4个同时执行的浮点加、7个同时执行的浮点/整数乘，
和一个浮点除。图C-18说明了如何通过扩展图C-17来绘制这个流水线。在图C-18中，重复间
隔是通过增加额外的流水级来实现的，它们由增加的流水线寄存器隔开。由于这些单元是相互，
独立的，所以我们分别对各级进行命名。需要多个时钟周期的流水级，比如除法单元，将被进
一步细分，以显示这些流水级的延迟。由于它们不是完整的流水级，所以只有一个操作是活动
的。这一流水线结构还可以使用本附录前面的类似图表展示，表C-18显示了一组独立的浮点运
算和浮点载入、存储指令。自然，浮点运算的较长延迟增加了 RAW 冒险和所导致停顿的频率，
在本节后面将会看到这一点。

一条支持同时执行多个浮点操作的流水线。浮点乘法器和加法器被完全流水化，深度分别为7
级和4级。浮点除法器未被流水化，而是需要24个时钟周期才能完成。在未招致RAW停顿的
情况下，从发射浮点操作到使用操作结果之间的指令延迟由执行级中消耗的周期数来决定。例
如，浮点加之后的第四条指令可以使用浮点加的结果。对于整数ALU操作，执行流水线的深度
总是为1，下一条指令就可以使用这些结果

表C-18
一组独立浮点运算的流水线时序
\begin{verbatim}
    MUL.D
    IF
    1D
    ADD.D
    L.D
    MI
    1D
    IF
    M2
    M3
    M4
    MS
    AI
    A2
    A3
    A4
    M6
    MEM
    M7
    WB
    MEM
    WB
    DD
    EX MEM WB
    S.D
    IF
    ID EX MEM WB
\end{verbatim}
*用斜体表示的流水级显示了需要数据的位置，而用粗体表示的減水级显示了有结果可用的位置。指伞标记待上的“.口”
扩展表示双糖度（64位）浮，点运算。浮，点栽入和存储使用64位路径连向存储器，所以流水线时序与整教栽入或存储一样。

图C-18中的流水线结构需要另外引人流水线寄存器（例如，A1/A2、A2/A3、A3/A4），并
修改连向这些寄存器的连接。ID/EX 寄存器必须进行扩展，以将 ID 连接到 EX、DIV、M1 和
Al；我们可以用标记 ID/EX、ID/DIV、ID/M1或 ID/AI 来引用与之后流水线之一相关联的寄存
器部分。ID 与所有其他流水级之间的流水线寄存器可以看作逻辑分离的寄存器，事实上也确实
可以实现为分离寄存器。由于在一个流水级中只能同时有一个操作，所以控制信息可以与该流
水级头部的寄存器关联在一起。

\subsection{长延迟流水线中的冒险与转发}
对于如图C-18所示的流水线，冒险检测与转发有许多不同方面。
\begin{enumerate}
    \item 因为除法单元未被完全流水化，所以可能发生结构冒险。需要对这些冒险进行检测，还E.54
    将需要停顿指令发射。
    \item 因为指令的运行时间不同，所以一个周期内需要的寄存器写人次数可能会大于1。
    \item 由于指令不会循序到达 WB，所以有可能存在写后写（WAW）冒险。注意，由于寄存
    器读总是在 ID 中发生，所以不可能存在读后写（WAR）冒险。
    \item 指令的完成顺序可能不同于其发射顺序，从而导致异常问题；我们将在下一小节解决这
    一问题。
    \item 由于操作的延迟较长，所以 RAW冒险的停顿将会变得更为频繁。
\end{enumerate}

由于操作延迟较长而导致停顿的增加，基本上与整数流水线一样。在描述这一浮点流水线
中出现的新问题并探讨其解决方案之前，先让我们研究一下 RAW冒险的可能影响。表C-19给
出了一个典型浮点代码序列和最终的停顿。在这一节的末尾，将会研究这一浮点流水线中我们
所选部分 SPEC的性能。

表C-19一个典型浮点代码序列展示了因为RAW冒险导致的停顿
\begin{verbatim}
    时钟周期数
    指令1
    2
    3
    4
    567891011 12 13 14 15 16
    17
    •L.D F4.0（R2）
    EX MEM WB
    MUL.D F0,F4,F6
    正F
    ID 停顿 M1 M2 M3 M4 M5 M6 M7 MEMWB
    ADD.D
    F2,F0.F8
    F 停顿 ID 停顿 停顿 停顿 停顿 停顿 停顿 A1 A2 A3 A4 MEMWB
    S.D
    F2.0（R2）
    正 停顿 停顿 停顿 停顿 停顿 停顿 ID EX 停顿 停顿 停顿 MEM
\end{verbatim}
*与较浅的整数流水线相比，较长的流水线大体会增大停顿频率。这个序列中的每条指令都会依赖于先前的指令，而
且只要数据可用就可以继续进行，这里假定減水线具有完全旁通和转发。S.D必须多停顿一个周期，使其 MEM不会
与 ADD.D冲究。添加硬件可以很轻松地处理这种情况。

现在看看因为写入导致的问题，如前面列表中第（2）项和第（3）项所述。如果我们假定浮点寄
存器堆有一个写端口，那么浮点操作序列（以及浮点载入指令与浮点运算的结合）可能导致寄
存器写端口的冲突。考虑表C-20所示的流水线序列。在时钟周期11中，所有3条指令将到达
WB，希望写人寄存器堆。由于仅有一个寄存器堆写入端口，所以处理器必须依次完成各条指
令。这个单一寄存器端口就代表着一种结构化冒险。我们可以增加端口的数目来解决这一问题，
但由于所增加的写人端口可能很少用到，所以这种解决方案可能并没有什么吸引力。之所以很
少用到这些端口，是因为写人端口的最大稳定状态数为1。我们选择检测对写端口的访问，将
其作为结构胃险加以实施。

表C-20
3条指令希望同时对浮点寄存器堆执行写回操作，如时钟周期11所示
时钟周期编号
\begin{verbatim}
    指令
    1
    2
    3
    4
    5
    6
    7
    ⑧
    9
    10
    11
    MUL.D FO,F4,F6
    1D
    M1
    M2
    MB
    M4
    M5
    M6
    M7
    MEM
    WB
    ID
    EX
    MEM
    WB
    IF
    ID
    BX
    MEM
    WB
    ADD.D
    F2.F4,F6
    IF
    ID
    A1
    A2
    A3
    A4
    MEM
    WE
    正
    1D
    EX
    MEM
    WE
    EX
    MEM
    WB
    F2.0（R2）
    IF
    DD
    EX
    MEM
    WB
\end{verbatim}
• 这不是最坏情况，因为浮，点单元中的先前除法操作也可能在同一时鈡兩期完成。注意，尽管在时钟周期10中，MUJL..D、
ADD.D和L.D都处于 MEM级，但仅有L.D在实际使用该存储器，所以关于 MIEM不存在结构性胃险。

共有两种不同方法来实现这一互锁。第一种方法是跟踪ID级对写端口的使用，并在一条指
令发射之前使其停顿，就像对于任何其他结构冒险一样。可以用一个移位寄存器来跟踪写端口
的使用，这个移位寄存器可以指示已发射指令将会在何时使用这个寄存器堆。如果 ID 中的指令
需要与已发射指令同时使用寄存器堆，那ID 中的指令将会停顿一个周期。在每个时钟周期，保
留寄存器将会移动1位。这种实现有一个好处——它能保持一个特性：所有互连检测与停顿插
人都在 ID流水级内进行。其成本是需要增加移位寄存器和写冲突逻辑。我们在本节始终假定采
用这一机制。

一种替代方案是当一个冲突指令尝试进入 MEM级或WB级时，使其停顿。如果我们等到
冲突指令希望进人 MEM或 WB级时才使其停顿，可以选择停顿任一指令。一种简单的启动式
方法（尽管有时是次优方法）是为那些延迟最长的单元赋予优先级，这是因为它是最可能导致
另一指令因 RAW 冒险而停顿的指令。这种方案的好处在于在进入容易检测冲突的 MEM或 WB
级之前不需要检测冲突。缺点是，由于停顿现在可能会出现在两个地方，所以使流水线控制变
得复杂。注意，在进入 MEM之前的停顿将会导致EX、A4或 M7 流水級被占用，可能会强制
停顿返回流水线中。同样，WB之前的停顿将会导致 MEM倒退。

我们的另一个问题是可能出现WAW冒险。为了看到这些冒险的存在，考虑表C-20中的示
例。如果L.D指令早一个周期发射，且其目的地为F2，则会产生 WAW 冒险，因为它会早于 ADD.D
一个周期写人 F2。注意，只有当 ADD.D 的结果被改写，而且从来没有任何指令使用这一结果时，
才会发生这一冒险！如果在 ADD.D和L.D之间会用到F2，那流水线将会因为RAW 冒险而需要停
顿，在ADD.D完成之前不会发射L.D。对于这个流水线，我们可以宣称只有在发射无用指令时才
会发生 WAW冒险，但仍然必须检测这些冒险，并在完成工作时确保L.D 的结果出现在F2中。（在
C.8 节将会看到，这些序列有时的确会出现在某些经过深思熟虑的代码中。）

有两种可能方式来处理这一 WAW 冒险。第一种方法是延迟载人指令的发射，直到 ADD.D
进入 MEM 为止。第二种方法是废除 ADD.D 的结果：检测冒险并改变控制，使ADD.D 不会写入其
结果。之后L.D就可以立即发射。由于这种冒险非常少见，所以两种方案都很有效——可以选
择任何一种易于实现的方案。在任一情况下，都可以在发射L.D的ID期间检测冒险，使L.D停
顿或者使ADD.D成为空操作都很容易。难以处理的情景是检测L.D可能在ADD.D之前完成，因为
这时需要知道流水线的长度和 ADD.D的当前位置。幸运的是，这一代码序列（两个写操作之间
没有插入读操作）很少出现，所以可以使用一种简单的解决方案：如果 ID 中的一条指令希望和
一条已经发射的指令同时写同一寄存器，就不要向EX 发射措令。在C.7节，我们将会看到如
何增加硬件来消除因为这些冒险导致的停顿。接下来，我们将浮点流水线中的冒险和发射逻辑
的实现细节结合在一起。

在检测可能出现的冒险时，必须考虑浮点指令之间的冒险，以及浮点指令与整型指令之间
的冒险。除了浮点载人-存储和浮点-整数寄存器移动之外，浮点与整数寄存器是相互分离的。
所有整数指令都是针对整数寄存器进行操作，而浮点操作仅对它们自己的寄存器进行操作。因
此，在检测浮点与整数指令之间的冒险时，只需要考虑浮点载人-存储和浮点寄存器移动。流水
线控制的这种简化是整数和浮点数据采用分离寄存器堆的另一项好处。（其主要好处是在各寄
存器堆数目不变的情况下使寄存器数目加倍，还能在不增加各寄存器端口的情况下增加带宽。
除了需要增加寄存器堆之外，其主要缺点是偶尔需要在两组寄存器之间进行移动所带来的微小
成本。）假定流水线在 ID 中进行所有冒险检测，必须在执行3种检查之后才能发射一条指令。

\begin{enumerate}
    \item 检查结构冒险——一直等到所需要功能单元不再繁忙为止（在这个流水线中，只有除法
    操作需要），并确保在需要寄存器写端口时可用。
    \item 检查RAW 数据冒险—直等到源寄存器未被列为流水线寄存器中的目的地为止。（当
    这一指令需要结果时，这些寄存器不可用。）这里需要进行大量检查，具体取决于源指令和目标
    指令，前者决定结果何时可用，后者决定何时需要该取值。例如，如果ID 中的指令是一个浮点
    运算，其源寄存器为F2，那F2在ID/A1、A1/A2或 A2/A3中不能被列为目的地，它们与一些
    浮点加法指令相对应，当ID中的指令需要结果时，这些指令还不能完成。（ID/A1是 1输出寄
    存器中被发送给A1的部分。）如果我们希望重叠执行除法的最后几个周期，由于需要将除法接
    近完成时的情景作为特殊情况加以处理，所以除法运算需要的技巧性更强一些。实际上，设计
    师可能会忽略这一优化，以简化发射测试。
    \item 检查 WAW数据冒险—判断A1，⋯，A4，D，M1，⋯，M7中是否有任何指令的目
    标寄存器与这一指令相同。如果确实如此，则暂停发射ID中的指令。
\end{enumerate}

尽管对于多周期浮点运算来说，冒险检测要更复杂一些，但其概念与 MIPS 整数流水线是
一样的。对于转发逻辑也是如此。可通过以下方式来实现转发：检查 EX/MEM、A4/MEM、
M7/MEM、D/MEM或 MEM/WB 寄存器中的目标寄存器是否为浮点指令的源寄存器之一。如果
确实如此，则必须启用适当的输人多工器，以选择转发数据。在练习中，读者将有机会为 RAW
和 WAW冒险检测以及转发指定逻辑。

多周期浮点操作还为我们的的异常处理方案带来了问题，接下来将予以处理。

\subsection{保持精确异常处理}
用以下代码序列可以说明长时间运行指令所导致的另一个问题：
\begin{verbatim}
    DIV.D
    F0,F2,F4
    ADD.D
    F10,F10,F8
    SUB.D
    F12,F12,F14
\end{verbatim}
这一代码序列看起来非常筒单；其中没有相关性。但是，由于指令的完成顺序可能不同于其发
射顺序，所以会出现一个问题。在这个示例中，我们可能预期 ADD.D 和 SUB.D先于 DIV.D之前完
成。这称为乱序完成，在拥有长时操作的流水线中很常见（见C.7节）。由于冒险检测会禁止违
反指令之同的任何相关性，那乱序完成为什么会成为一个问题呢？假定在 ADD.D 已经完成而
DIV.D还未完成时，SUB.D导致了浮点算术异常，最终会出现我们应当尽力避免的不精确异常。
看起来，我们似乎可以像对整数流水线那样，通过清空浮点流水线来解决这一问题。但是，异
常的发生位置可能无法让我们清空流水线。例如，如果DIV.D决定在完成加法之后获取浮点算
术异常，那可能无法获得硬件级别的精确异常。事实上，由于 ADD.D破坏了它的一个操作数，
所以即使在软件的帮助下，也无法恢复到 DIV.D之前的状态。

这一问题的出现是因为指令的完成顺序与其发射顺序不同。共有四种可能方法来处理乱序
完成情况。第一种是忽略问题，容忍非精确异常。20世纪60年代和70年代早期采用这一方法。
在某些超级计算机中仍在使用这种方法，在这种超级计算机中，某些特定类型的异常或者不允
许出现，或者由硬件进行处理，不需要使流水线停止。在大多数现代处理器中很难使用这一方
法，因为虚拟存储器等功能和 IEEE 浮点标准都需要通过软件和硬件的组合来实现精确异常。
前面曾经提到，最近的一些处理器已经通过引人两种执行模式解决了这一问题，一种模式速度
很快，但可能是非精确的，另一种模式较慢，但却是精确的。在实现较慢的精确模式时，或者使
用模式切换，或者显式插人一些指令，用于测试浮点异常。无论采用哪种实现方式，浮点流水线
中所允许的重叠和重新排序数目都受到严重限制，以实现在同一时间只有一条浮点指令是活动
的。在 DEC Alpha 21064 和 21164、IBMPowerl 和 Power2、MIPS R8000中都采用这一解决方案。

第二种方法是缓冲—个操作的结果，直到先前发射的所有操作都完成为止。一些CPU实际
上使用了这一方案，但是，当操作的运行时间差别很大时，由于要缓冲的结果数变得非常庞大，
所以这种方法的成本就会非常高昂。此外，必须绕过来自队列的结果，以便在等待较长指令的
同时继续发射指令。这就需要大量比较器和一个非常大的乘法器。

这一基本方法有两种可行的变化形式。第一种形式是CYBER 180/990中使用的历史文件。
历史文件跟踪寄存器的原始值。在发生异常而且必须将状态回滚到某一乱序完成的指令之前时，
可以从历史文件中恢复寄存器的原始值。在诸如VAX之类的处理器上，采用一种类似技术来实
现自动递增和自动递减寻址。另一种方法是由 Smith 和 Pleszkum［1998］提出的未来文件，它跟
踪寄存器的较新值；当所有先前指令均已完成时，则从未来文件中更新主寄存器堆。当发生异
常时，主寄存器堆拥有中断状态的精确值。在第3章，我们看到在 PowerPC 620 和 MIPS R10000
等处理器中使用了这一思路的扩展，可以在保持精确异常的同时进行重叠和重新排序。

所使用的第三种方法是允许异常变得不十分精确，但保存足够的信息，以便陷阱处理例程
可以生成精确的异常序列。这意味着要知道流水线中有哪些操作以及其PC。因此，在处理异常
之后，由软件完成那些最后完成指令之前的所有指令，然后该序列就能重新启动了。考虑以下
最糟代码序列：

指令，-最終中断执行的长时运行指令。
指令2，⋯，指令w-———系列未完成的指令。
指令 条已完成指令。

给定流水线中所有指令的 PC和异常返回 PC之后，软件就可以得到指令，和指令，的状态。由
于指令，已经完成，所以我们希望在指令 mtl重新开始执行。在处理异常之后，软件必须模拟指
令1，⋯，指令=-l的执行。然后，我们可以从异常中返回，并在指令 n+ 重新启动。由处理器正
确执行这些指令的复杂性才是这一方案的主要挑战。

对于简单的类 MIPS 流水线，有一个重要简化：如果指令2，⋯，指令，都是整数指令，那
我们就知道当指令，完成时，指令2，…，指令 I也都已完成。因此，只有浮点操作需要处理。
为使这一情况易于处理，必须限制可以重叠执行的浮点指令数。例如，如果我们仅重叠两条指令，
那只有中断指令需要由软件来完成。如果浮点流水线很深，或者如果存在大量浮点功能单元，那
这一限制可能会限制吞吐量。SPARC体系结构中使用了这一方法，以允许重叠浮点与整数操作。

最后一种方法是一种混合方案，它仅在确保所发射指令之前的所有指令都已完成，而且没
有导致异常时，才允许继续指令发射。这样就能确保在发生异常时，中断指令之后的指令都不
会完成，而中断指令之前的全部指令都可以完成。这意味着有时要停顿CPU，以保持精确异常。
为便这一方案有效，浮点功能单元必须在 EX 流水级的早期判断是否可能存在异常（这里所说
的早期，在 MIPS 流水线中是指前三个周期），以阻止进一步完成其他指令。MIPS R2000/3000、
R4000和 Intel Pentium中使用了这一方案。在附录J中将对其进行深入讨论。

\subsection{MIPS浮点流水线的性能}

图C-18中的 MIPS 浮点流水线既可以对除法单元生成结构性停顿，也可以对RAW 冒险生
成停顿（它还可能拥有WAW冒险，但在实际中很少发生）。图C-19以各实例为基础，列出了
每种浮点操作的停顿周期数目（即，每个浮点基准测试的第一个长条表示每个浮点加、减或转
换的浮点结果停顿数）。可以看到，每个操作的停顿周期与浮点运算的延迟相关，介于功能单元
延迟的46%~59%之间。

对于 SPEC89浮点基准测试，每种主要浮点运算类型的停顿。除了除法结构性冒险之外，这些
数据与运算的频率无关，仅取决于它的修改和使用结果之前的周期数。RAW 冒险造成的停顿数
大体与浮点单元的延迟数保持一致。例如，每个浮点加、减或转换的平均停顿数为1.7个周期，
也就是延迟（3个周期）的569。与此类似，乘法与除法的平均停顿数分别为2.8和14.2，也就
是相应延迟的46%和 59%。除法的结构性冒险很少见，这是因为除法频率很低的原因


图C-20给出了5种SPEC印p基准测试整数与浮点停顿的完整分类。图中共给出4类停顿：
浮点结果停顿、浮点比较停顿、载入与分支延迟、浮点结构延迟。编译器尝试在调度分支延迟
之前调度载人与浮点延迟。每个指令的总停顿数介于0.65~1.21之间。

针对5种 SPEC89浮点基准测试，MIPS浮点流水线上发生的停顿。每条指令的总停顿数变化
范围为 su2cor 的0.65到doduc的1.21，平均值为0.87。在所有情况下，浮点结果停顿都占绝大
多数，每条指令平均为0.71次停顿，也就是停顿間期的82%。比较操作生成的停顿数为每条指
令平均0.1 次，为第二大停顿源。除法结构性冒险的影响仅在 doduc 测试中比较明显一些

\section{融会贯通：MIPS R4000流水线}
在本节，我们将研究MIPS R4000 处理器系列的流水线结构和性能，该系列包括4400。
R4000实现MIPS64，但它整数和浮点程序使用的流水线深度都超过我们使用的五级流水线设
计。这一较深流水线可以将五级整数流水线分解为八级，以允许实现更高的时钟频率。由于缓
存访问的时间要求很高，所以通过分解存储器访问可以获得更多的流水级。这种更深的流水线
有时被称为超流水线。

图C-21显示了八级流水线结构，其中使用了数据路径的抽象版本。图C-22显示了流水线
中连续指令的重叠。注意，尽管指令和数据存储器占用多个周期，但它们已经完全实现流水化，
所以在每个时钟周期都可以开始一条新指令。事实上，流水线会在完成缓存命中检测之前使用
数据；第2章更详细地讨论了如何完成这一过程。

每一流水级的过程如下所述。
\begin{itemize}
    \item IF-一指令提取的前半部分，PC选择与指令缓存访问的初始化实际上发生在这里。
    \item IS——指令提取的后半部分，完成指令缓存访问。
    \item RF—-指令译码与寄存器提取、冒险检查、指令缓存命中检测。
    \item EX--执行，包括实际地址计算、ALU操作和分支目标计算与条件判断。
    \item DF—数据提取，数据缓存访问的前半部分。
    \item DS-数据提取的后半部分，完成数据缓存访问。
    \item TC-标记检查，判断数据缓存访问是否命中。
    \item WB载入和寄存器-寄存器操作的写回过程。
\end{itemize}

R4000 的八级流水线结构使用流水化指令与数据缓存。图中对流水级进行了标记，它们的详细
功能用文字描述。垂直虚线表示流水级界限以及流水线锁的位置。指令实际上在IS结東时可供
使用，但标记检查是在 RF完成的，与此同时提取寄存器值。因此，我们将指令存储器标记为
在整个 RF中运行。由于在知道缓存访问是否命中之前，不能将数据写人寄存器，所以数据存
储器访问需要TC级

图C-22 R4000 整数流水线的结构导致了2周期载入延迟。由于数据值在 DS 结束时可用，而且可能被
旁路，所以有可能产生2周期延迟。如果 TC中的标记检查显示这是一次敏失，则流水线将回
退一个周期，在此时刻有正确数据可供使用

除了显著增加所需要的转发数量之外，这种较长延迟的流水线既会增加载入延迟，又会增
加分支延迟。由于数据值在DS的末尾才可用，所以图C-22.将载入延迟显示为2个周期。表C-21
显示了在载入指令之后立即使用的简略流水线调度。它显示在3个或4个周期之后使用载入指
令的结果时，就需要进行转发。

图 C-23显示基本分支延迟为3个周期，这是因为分支条件是在 EX期间计算的。MIPS体
系结构有一个延迟1周期的分支。R4000为该分支延迟的其余2个周期使用预测未选中策略。
如表C-22所示，未选中分支就是延迟1个周期的分支，而选中分支是在一个1周期延迟时隙之
后跟有2个空闲周期。这一指令集提供了一种类似于分支的指令，前面已经对其进行了介绍，
它可以帮助填充该延迟时隙。流水线互锁一方面要插人选中分支的2周期分支停顿代价，另一
方面也造成因为使用载人结果而导致的数据冒险停顿。

表C-21 在载入指令之后立即使用结果时会产生2周期的停顿
\begin{verbatim}
    时钟编号
    指令编号
    LD
    R1....
    1
    FF
    2
    I
    DADD
    R2.RI...
    3
    RF
    IS
    4
    5
    6
    7
    EX
    DF
    DS
    TC
    RF
    停顿
    停顿
    EX
    DSUB
    R3,RI.•
    IS
    停顿
    停顿
    RF
    OR
    R4,Ri.
    正
    停顿
    停顿
    IS
    8
    WE
    DF
    EX
    RF
    ，9
    DS
    DF
    •EX
\end{verbatim}
• 通常的转发路径可在2个周期之后使用，所以 DADD 和 DSUB 通过傳顿之后的特发来获取其取值。OR 指令从寄存器推中获
取讓值。由于載入之后的两条指令可能是独立的，因此不会停顿，所以旁路可能指向載入之后3或4个周期的指令。
时间《以时钟周期为单位）

图 C-23 由于条件判断是在 EX进行的，所以基本分支延迟为3个周期
深度流水线除了增加载人与分支的停顿之外，还会增加 ALU运算的转发级别数。在MIPS
五级流水线中，两个寄存器-寄存器 ALU 指令之间的转发可能发生于 ALU/MEM 或 MEM/WE
寄存器。在 R4000流水线中，ALU 旁路可能有4种可能来源：EX/DF、 DF/DS、 DS/TC 和TC/WB。

表C-22
如表中上半部分所示，选中分支有一个1周期延迟时隙，后面跟有一个2周期停顿，而如表中下半
部分所示，未选中分支只有一个1周期延迟时隙
指令编号
分支指令
延迟时隙
停顿
停顿
分支目标
1
邛F
2
IS
3
RF
IS
停顿
4
EX
RF
停顿
停顿
时钟编号
5
DF
EX
停顿
停顿
FF
9
WB
停顿
停顿
DF
时钟编号
指令编号
分支指令
延迟时隙
分支措令+2
分支指令+3
1
邛F
2
一TS
FF
3
RF
IS
TF
4
5
EX
DF
RF
EX
IS
RF
IF
IS
6
Ds
DF
EX
RF
7
TC
DS
DF
EX
8
WE
TC
DS
DF
9
WB
TC
ps

*分支指令可以是一个普通延退分支，也可能是类似于分支的指令，在分支来被选中时，取消延退时陈中的指令救果。

\subsection{浮点流水线}

R4000浮点单元由3个功能单元缓存：浮点除法器、浮点乘法器和浮点加法器。加法逻
辑在乘法或除法的最后一个步骤使用。双精度浮点运算可能占用2个周期（对于求相反数）到
112个周期（对于求平方根）。此外，各种单元的起始速度不同。浮点功能单元可以看作拥有8
个不同流水级，如表C-23中所列；以不同顺序组合这些流水级，即可执行各种浮点运算。

表C-23 R4000浮点流水线中使用的8个流水级
流水级
A
D
E
M
N
R
功能单元
浮点加法器
浮点除法器
浮点乘法器
浮点乘法髁
浮点乘法器
浮点加法器
浮点加法器
U
描述
尾数加ADD流水级
除法流水级
异常测试流水级
乘法器的第一流水级
乘法器的第二流水级
舍人流水级
操作数移位流水级
提取浮点数

这些流水级的每个流水级都有单个副本，各种指令对一个流水级可以使用0次或多次，使
用顺序也可以不同。表C-24给出了最常见双精度浮点运算所使用的延迟、初始速率和流水级。

表C-24 浮点运算的延迟和初始间隔都取决干给定运算必须使用的浮点单元级

*延迟值假定目标指令是一个浮，点运算。当目标指令为存储指令时，延迟会少 1个周期。流水級的显示顺序就是各个
运算使用它们的顺序。标记 S+A表示在这个时钟周期内同时使用S 和A流水級。标记 D2表示 D流水級在一行中使
用28次。

根据表C-24中的信息，我们可以判断一个由不同独立浮点运算组成的序列是否可以无停顿
发射。如果因为该序列的时序而对于共享流水级发生冲突，则需要停顿。表C-25、表C-26、表
C-27、表C-28给出了4种可能存在的常见两指令序列：乘法后面跟有加法、加法后面跟有乘法、
除法后面跟有加法、加法后面跟有除法。这些表中显示了第二条指令所有感兴趣的起始位置，
以及第二条指令在每个位置是发射还是停顿。当然，可能一共有三条指令是活动的，在这种情
况下，发生停顿的可能性要高得多，列表也要更为复杂。

表C-25 在时钟周期0发射的浮点乘法在后面跟有一个在时钟周期1和时钟周期7之间发射的单个浮点加

*第二列指出一个特定类型的指令在 n个周期之后发射时是否会傳顿，其中n 为时鈡周期编号，在此周期內发生第二
指令的U级。导致停顿的流水级用黑体表示。注意，这个表仅给出了乘法指令与时钟周期1、7之间发射的一个加法
指令之间的交互。在这种情况下，如果加法指令在乘法之后 4或 5个周期发射，則该加法指令会傳顿；否則，它食
无停顿发射。注意，如果加法指令在周期4 发射，由于它在下一个时钟周期仍然会与乘法指令相冲突，所以加法指
令会傳顿2个周期；但是，如果加法指令在周期5发射，由于选样会消除冲突，所以它仍然仅停顿1个时钟周期。

表C-26 在加法之后发射的乘法总是可以无停顿继续进行，这是困为较长指令到达共享流水级之前，较短
指令会清空它们

表C-27 如果加法指令在浮点除法指令结束时启动，该浮点除法可能导致该加法指令的停顿
时钟周期

* 除法在周期0处开始，在周期35处完成；表中给出除法的最后10 个周期。由于除法指令大量使用了加法指令所需要
的舍入硬件，因此，只要加法指令是在周期28 至周期33 中的任一周期中启动，讓除法指令都会使其停颇。注意，
在周期28处启动的加法指令将一直傳顿到周期36。如果加法指令在除法指令之后立即启动，由于加法指令可能在除
法指令用到共享流水级之前完成，所以不会导致冲突，如同我们在表C-26中的乘加一样。和前面的表一样，这个示
例假定在时钟周期26和35之间只有一个加法指令到达UI级。

表C-28 双精度加之后跟有双精度除

*如果除法指令晚于加法1个周期启动，则除法指令会停顿，但在此之后不存在冲突。

\subsection{R4000流水线的性能}
本节，我们将研究在R4000流水线结构上运行 SPEC92 基准测试时所发生的停顿。流水线
停顿或损失的原因共有四大类。

（1） 载入停顿-一在载人之后1或2个周期再使用载入结果时导致的延迟。
（2）分支停顿-每个选中分支上发生的两周期停顿再加上未填充或已取消分支延迟时隙。
（3） 浮点结果停顿-—因为浮点操作数的RAW冒险所导致的停顿。
（4） 浮点结构停顿--因为浮点流水线中功能单元的冲突产生发射限制，进而导致的延迟。

图C-24给出了对于10个 SPEC92 基准测试，R4000流水线的流水线CPI分类。表C-29给出了
相同的数据。

图 C-24 10个SPEC92 基准测试的流水线 CPI，假定采用完美缓存。流水线 CPI的变化范围为1.2~-2.8。
最左边的5个程序为整数程序，分支延迟是CPI 的主要组成因素。最右边5个程序为淨点程序，
浮点结果停顿是其主要因素。表C-29给出了绘制这一图形的数值

表C-29 显示了总流水线CPI的4个主要停顿源
\begin{verbatim}
    基准测试
    Compress
    Eqntott
    Espresso
    Gcc
    Li
    整数平均值
    流水线CPI
    载入停顿
    分支倳顿
    浮点结果停顿
    1.20
    0.14
    0.06
    0.00
    1.88
    0.27
    0.61
    0.00
    1.42
    0.07
    0.35
    0.00
    156
    0.13
    0.43
    0.00
    164
    0.18
    0.46
    0.00
    1.$4
    0.16
    0.38
    0.00
    浮点结构性停顿
    0.00
    0.00
    0.00
    0.00
    0.00
    0.00
    C-67
    504
    附录C 流水线：基础与中级概念
    C-68
    C-69
    C-70
    （续）
    基准测试
    流水线CPI
    载入停顿
    分支停顿
    浮点结果停顿
    浮点结构性倳顿
    Diduc
    2.84
    0.01
    0.22
    1.39
    0.22
    Mdljdp2
    2.66
    0.01
    0.31
    1.20
    0.15
    Ear
    2.17
    0.00
    0.46
    0.59
    0.12
    Hydro2d
    2.53
    0.00
    0.62
    0.75
    0.17
    Suzcor
    2.18
    0.02
    0.07
    0.84
    0.26
    浮点平均值
    2.48
    0.01
    0.33
    0.95
    0.18
    整体平均億
    2.00
    0.10
    0.36
    0.46
    0.09
\end{verbatim}

*主要因素汐浮点结果停顿（对于分支和浮，点输入均是如此）和分支停顿，載入停顿和浮，点结构性停顿的影响很小。•
根据图 C-24和表C-29中的数据，可以看出深度流水线的代价。与经典五级流水线相比，
R4000流水线的分支延迟要长得多。较长的分支延迟会显著增加在分支上花费的周期数，特别
是对于分支频率较高的整数程序。浮点程序一个值得注意的影响是：与结构性冒险相比，浮点
功能单元的延迟会导致更多的停顿，主要源于初始间隔限制和不同浮点指令对功能单元的冲突。
因此，降低浮点运算的延迟应当是第一目标，而不是实现功能单元的更多流水线或重复。当然，
降低延迟可能会增加结构性停顿，这是因为许多潜在的结构性停顿被隐藏在数据冒险之后。

\section{交叉问题}
\subsection{RISC指令集及流水线效率}
我们已经讨论了指令集简化对于构建流水线的好处。简单指令集还有另外一个好处：这样
可以更轻松地调度代码，以提高流水线的执行效率。为了解这一点，考思一个简单示例：假定
我们需要对存储器中的两个值相加，并将结果存回存储器。在一些高级指令集中，这一任务只
需要一条指令；而在其他一些指令集中则需要两条或三条指令。一个典型的 RISC 体系结构需
要四条指令（两条载入指令、一条加法指令和一条存储指令）。在大多数流水线中，不可能在没
有插入停顿的情况下顺序调度这些指令。

对于 RISC 指令集，各个操作都是单独的指令，可以使用编译器进行各别调度（使用我们
前面讨论的技术以及第3章讨论的功能更强大的技术）或动态硬件调度技术进行各别调度（将
在下面讨论，第3章进行了更详细的讨论）。这些效率优势如此明显，再加上其实现非常容易，
所以复杂指令集的几乎所有近期流水线实现实际上都将其复杂指令转换为类似于 RISC的简单
操作，然后再对这些操作进行调度和流水化。第3章中显示 Pentium III 和 Pentium 4都使用了这
一方法。

\subsection{动态调度流水线}

简单流水线提取一条指令并发射它，除非流水线中的已有指令和被提取的指令之间存在数
据相关性，而且不能通过旁路或转发来隐藏。转发逻辑降低了实际流水线延迟，使特定的相关
性不会导致冒险。如果存在不可避免的冒险，则冒险检测硬件会使流水线停顿（从使用该结构
的冒险开始）。在清除这种相关性之前，不会提取或发射新指令。为了弥补这些性能损失，编译
器可以尝试调度指令来避免冒险；这种方法称为编译调度或静态调度。

几种早期处理器使用了另外一种名为动态调度的方法，硬件借此方法重新安排指令的执行
过程，以减少停顿。本节通过解释CDC6600的记分卡技术，简要介绍了动态调度问题。一些读
者会发现，在阅读这一材料之后再去深人研究第3章讨论的较为复杂的 Tomasulo 方案，会更容
易一些。

到目前为止，本附录讨论的所有技术都使用循序指令发射，这意味着如果一条指令在流水
线中停顿，将不能处理后续指令。在采用循序发射时，如果两条指令之间存在冒险，即使后面
存在一些不相关的、不会停顿的指令，流水线也会停顿。

在前面开发的 MIIS 流水线中，结构性冒险和数据冒险都是在指令译码（ID）期间进行检
查的：当一条指令可以正确执行时，该指令是从ID发射出去的。为使一条指令在其操作数可用
时立即开始执行，不受其先前停顿指令的影响，我们必须将发射过程分为两部分：检查结构性
冒险，等待数据冒险的消失。循序对指令进行译码和发射；但是，我们希望指令在其数据操作
数可用时立即开始执行。因此，流水线是乱序执行的，也就暗示是乱序完成的。为了实现乱序
执行，我们必须将ID 流水级分为两级。

（1） 发射—指令译码，检查结构性冒险。
（2） 读取操作数—等到没有数据冒险，随后读取操作数。

IF级进人发射级，EX级跟在读取操作数级之后，这一点与 MIPS 流水线中一样。同 MIPS
浮点流水线一样，执行可能占用多个周期，具体取决于所执行的操作。因此，我们可能需要区
分一条指令何时开始执行，何时完成执行；在这两个时刻之间，指令处于执行过程中。这样就
允许多条指令同时处于执行过程中。除了对流水线结构的修改之外，我们还将改变功能单元设
计：改变单元数、操作延迟和功能单元流水化，以更好地探索这些更高级的流水线技术。
采用记分卡的动态调度

在动态调度流水线中，所有指令都循序通过发射级（循序发射）；但是，它们可能在第二级
（读取操作数级）停顿，或绕过其他指令，然后进行乱序执行状态。记分卡技术在有足够资源、
没有数据依赖性时，允许指令乱序执行；这一功能是在CDC 6600记分卡中开发的，并因此而
得名。

在我们了解如何在 MIIPS 流水线中使用记分卡之前，非常重要的一点是要观察到当指令乱
序执行时可能会出现 WAR冒险，这种冒险在 MIPS浮点或整数流水线中是不存在的。例如，考
虑以下代码序列：

\begin{verbatim}
    DIV.D
    FO,F2,F4
    ADD.D
    F10,F0, F8
    SUB.D
    F8,F8,F14
\end{verbatim}

ADD.D和SUB.D之间存在一种反相关性：如果流水线在 ADD.D之前执行 SUB.D，它将违犯反相关性，
产生错误的执行结果。与此类似，为避免违反输出相关性，也必须检查 WAW 冒险（例如，当
SUB.D的目标寄存器为F10时将会发生此种冒险）。后面将会看到，记分卡通过停顿反相关中涉
及的后续指令，避免了这两种冒险。

记分卡的目标是：通过尽早执行指令，保持每时钟周期1条指令的执行速率（在没有结构
性冒险时）。因此，当下一条要执行的指令停顿时，如果其他指令不依赖于任何活动指令或停顿
指令，则发射和执行这些指令。记分卡全面负责指令发射与执行，包括所有冒险检测任务。要
充分利用乱序执行，需要在其 EX 级中同时有多条指令。这一点可以通过多个功能单元、流水
化功能单元或同时利用两者来实现。由于这两种功能（流水化功能单元和多个功能单元）对于
流水线控制来说基本上是等价的，所以我们将假定处理器拥有多个功能单元。

CDC 6600拥有16个独立的功能单元，包括4个浮点单元、5个存储器引用单元和7个整数
运算单元。在采用 MIPS 体系结构的处理器上，记分卡主要在浮点单元上发挥作用，因为其他
功能单元的延迟非常小。让我们假定一共有两个乘法器、一个加法器、一个除法单元和一个完
成所有存储器引用、分支和整数运算的整数单元。尽管这个例子要比CDC 6600 简单，但它的
功能足以演示这些原理，不需要大量细节，也不需要非常长的示例。因为 MIPS 和 CDC 6600
都是载人-存储体系结构，所以这些技术对于这两种技术来说几乎是相同的。图C-25给出了该
处理器的基本结构。

图C-25 带有记分卡的MIPS 处理骼的基本结构。记分卡的功能是控制指令执行（垂直控制线）。所有数
据在寄存器堆和总线上的功能单元之间流动（水平线，在CDC6600中称为干线）。共有两个浮点
乘法器、一个浮点除法器、一个浮点加法器和一个整数单元。一组总线（两个输人和一个输出）
充当一组功能单元。记分卡的细节在表C-30至表C-33 中给出

每条指令都进入记分卡，在这里构建一条数据相关性记录；这一步与指令发射相对应，并
替换 MIIPS流水线中的ID步骤。记分卡随后判断指令什么时候能够读取它的操作数并开始执行。
如果记分卡判断该指令不能立即执行，它监控硬件中的所有变化，以判断该指令何时能够执行。
记分卡还控制一条指令什么时候能将其结果写到目标寄存器中。因此，所有冒险检测与解决都
集中在记分卡。我们后面将会看到记分卡的一张表格（表C-30），但首先需要理解流水线发射
与执行部分的步骤。

每条指令需要经历4个执行步骤。（由于我们现在主要考虑浮点运算，所以不考虑存储器访
问步骤。）我们先粗略地查看一下这些步骤，然后再详细研究记分卡如何记录一些必要信息，用
于判断执行过程何时由一个步骤进行到下一个步骤。这四个步骤代替了标准 MIPS 流水线中的
ID、EX 和 WB步骤，如下所示。

\begin{enumerate}
    \item 发射—如果指令的一个功能单元空闲，没有其他活动指令以同一寄存器目标寄存
    器，则记分卡向功能单元发射指令，并更新其内部数据结构。这一步代替了 MIPS 流水线中心D
    步骤的一部分。只要确保没有其他活动功能单元希望将自己的结果写人目标寄存器，就能保证
    不会出现 WAW冒险。如果存在结构性冒险或 WAW冒险，则措令发射停顿，在清除这些冒险
    之前，不会再发射其他指令。当发射级停顿时，会导致指令提取与发射之间的缓冲区填满；如
    果缓冲区只是一项，则指令提取立即停顿。如果缓冲区是拥有多条指令的队列，则在队列填满
    后停顿。
    \item 读取操作数——记分卡监视源操作数的可用性。如果先前发射的活动指令都不再写人源
    操作数，而该源操作数可用。当源操作数可用时，记分卡告诉功能单元继续从寄存器读取操作
    数，并开始执行。记分卡在这一步动态解决 RAW 冒险，可以发送指令以进行乱序执行。这一
    步和发射步骤一起，完成了简单 MIPS 流水线中 TD步骤的功能。
    \item 执行—一功能单元接收到操作数后开始执行。结果准备就绪后，它通知记分卡已经完成
    执行。这一步代替了 MIPS流水线中的EX步骤，在 MIPS浮点流水线中耗用多个周期。
    \item 写结果 一旦记分卡知道功能单元已经完成执行，则检查 WAR冒险，并在必要时停
    顿正在完成的指令。
\end{enumerate}

如果有一个与我们先前示例相类似的代码序列，其中 ADD.D和SUB.D都使用 F8，则存在 WAR
冒险。在这个示例中，有如下代码：

\begin{verbatim}
    DIV.D
    FO,F2,F4
    ADD.D
    F10,FO,F8
    SUB.D
    F8,F8,F14
\end{verbatim}
ADD.D 有一个源操作数为F8，就是SUB.D的目标寄存器。但ADD.D实际上取决于前面的一条指令。
记分卡仍将 SUB.D停顿于它的写结果阶段，直到 ADD.D 读取它的操作数止。一般来说，在以下
情况下，不能允许一条正在执行的指令写人其结果：

口 在正在执行的指令前面（即按发射顺序）有一条指令还没有读取其操作数；
口 这些操作数之一与正执行指令的结果是同一寄存器。

如果不存在这一WAR 冒险，或者已经清除，则记分卡会告诉功能单元将其结果存储到目标寄
存器中。这一步骤代替了简单 MIIPS 流水线中的 WB步骤。

乍看起来，记分卡在区分RAW 和 WAR冒险时似乎会有困难。

因为只有当寄存器堆中拥有一条指令的两个操作数时，才会读取这些操作数，所以记分卡
未能利用转发。只有当寄存器都可用时才会进行读取。这一代价并没有读者最初想象得那么严
重。这里与我们前面的简单流水线不同，指令会在完成执行之后立即将结果写入寄存器堆（假
定没有WAR冒险），而不是等待可能间隔几个周期的静态指定写人时隙。由于结果的写人和操
作数的读取不能重叠，所以仍然会增加一个周期的延迟。我们需要增加缓冲，以消除这一开销。
记分卡根据自己的数据结构，通过与功能单元的沟通来控制指令从一个步骤到下一个步骤
的进展。但这种做法有一点点复杂。指向寄存器堆的源操作数总线和结果总线数目是有限的，
所以可能会存在结构性冒险。记分卡必须确保允许进入第（2）、（4）步的功能单元数不会超过可用
总线数。这里不会进行深人讨论，仅提及 CDC 6600在解决这一问题时，将16个功能单元分为
四组，并为每一组提供一组总线，称为数据干线。在一个时钟周期内，一个组中只有一个单元
可以读取其操作数或写人其结果。

现在让我们看一个拥有五个功能单元的MIPS记分卡所保持的详尽数据结构。表C-30显示
了在如下这一简单指令序列执行时，记分卡中的信息。
\begin{verbatim}
    L0
    F6,34（R2）
    L.D
    F2,45（R3）
    MIL.D
    FQ,F2.F4
    SuB.D
    F8,F6,F2
    DIV.D
    F10,F0,F6
    ADD.D
    F6,F8,F2
\end{verbatim}
表C-30 记分卡的组成。每条已经发射或正在发射的指令在指令状态表中都有一个对应项

*每个功能单元在功能单元状态表中有一个时应项。一旦发射一条指令后，就在功能单元状态表中保留其操作数记粟。
最后，寄存器状态表指示哪个单元将生成每个未给出的结果；项数与寄存器数相等。指令状态表表明：（1）第一个L.口
巴经完成并写入其结果，（2） 第二个L.D已经完成执行，但还没有写入其结果。MIL. D、SUB. D和 DIV.D 都已经发射，
但正在停顿，等待其操作教。功能单元状杰表明第一个乘法单元正在等待整数单元，加法单元正在等待整数单元，
除法单元正在等待第一个乘法单无。ADD.D指令因 结构性胃险而傳顿，当 SUB.D完成时将会清除这一冒险。如果这
些记分卡中莱个中的项目没有用到，則保持功空。例如，Rk字段在载入时没有用到，Mult2 单元没有用到，因此它
们的字段没有意义。另外，一旦读取一个操作数之后，Rj和Rk 宇段将被设置为“否”。表C-33 表明了最后一步海什
么至关重要。

记分卡共有三个部分，如下所述。

（1）指令状态—指出该指令处于四个步骤中的哪一步。
2） 功能单元状态——指出功能单元（FU）的状态。共有9个字段用来表示每个功能单元
的状态。

口忙—一指示该单元是否繁忙。
口 Op一在此单元中执行的运算（例如，加或减）。
F—目标寄存器。
口巧，Fk—源寄存器编号。
口 Qi,Qk—生成源寄存器F、Fk的功能单元。
口Rj, Rk—指示巧、F已准备就绪但尚未读取的标记。在读取操作数后将其设置为“否”。

（3） 寄存器结果状态—如果一条活动指令以该寄存器为目标寄存器，则指出哪个功能单元
将写人每个寄存器。只要没有向该寄存器写入的未完成指令，则将此字段设置为空。

现在让我们看一下在表C-30中开始的代码序列如何继续执行。之后，我们就能更详细地研
究记分卡用于控制执行的条件了。

例题
假定浮点功能单元的EX周期延迟如下（选择这些延迟是为了说明行为特性，并非
代表性数值）：加法为2个时钟周期，乘法为10个时钟周期，除法为40个时钟周
期。利用表C-30前面的代码段，并从表C-30中指令状态指示的时刻开始，说明当
MUL.D和DIV.D分别准备好写人结果状态时，状态表中是什么样的。

解答
从第二个 L.0到 MUL.D、ADD.D和 SUB.D，从MUL.0 到 DIV.O 和从 SUB.D到 ADD.D，存在
RAW数据冒险。在DIV.0 和ADD.D以及SUB.D之间存在WAR数据冒险。最后，加法
功能单元对于 ADD.D和SUB.D中存在结构性冒险。当MUL.D和 DIV.D准备好写人其结
果时，这些表分别如表C-31和表C-32所示。

表C-31在MJL.D写结果之前的记分卡表

*DIV.D还没有读取它的任何一个操作数，因为它依赖于乘法结果。ADD.D已经读取其操作数，并在执行
过程中，当然它必须要等到 SUB.D完成之后才能得到功能单元。由于存在对F6的WAR 胃险，所以 ADD.D
不能继续写结果，F6由DIV.D使用。只有当功能单无正在等待另一个单元时，Q宇段才有关联。

表C-32 在DIV.D写结果之前的记分卡表

*在 DIV.D读取操作数并获得 F6的副本之后，ADD.D立即就能完成。只有DIV.D指令仍然有待完成。
现在，我们可以研究一下为使每条指令能够继续，记分卡必须做些什么，以此
来详细了解记分卡是如何工作的。表C-33说明，为使每条指令能够继续执行，记分
卡需要些什么，并记录在指令继续执行时需要哪些必要的操作。记分卡记录操作数
标志符信息，比如寄存器编号。例如，在发射指令时，必须记录源寄存器。因为我
们将寄存器的内容称为 Regs［D］，其中D为寄存器名称，所以不存在模糊性。例如，
FJ［FU］-51会导致寄存器名称S1 被放在FJ［FU］中，而不是寄存器S1 的内容。
表C-33 指令执行过程中每个步骤需要的检查和记录操作

\begin{verbatim}
    指令状态
    发射
    在达到以下条件之前一直等待
    记录
    不 ［FUI，没有结果［D］
    BuSy［FUJ fyes: Op［FU］ <-op; Fi［FU］个D；
    Fj［FU］个S1;FK［FU］个S2；
    Qj<-Result［S1］；Qkt Result［S2］：
    Rjf not Qj; Rkt not Qk; Resuit［D］^FU；
    Rj个 No; Rk个 No; Qjf0; Qk个0
    读取操作数
    执行完成
    写结果
    Rj和Rk
    功能单元完成
    VfCFIV］ FiIFUI or Rijlf］=No） & V/Cif QJU］-FU then RjUfI Yes）；
    （FKIf］！FILFU］ or RKI/1= No））
    vf（if Qkif］=FU then RkUf］fYes）；
    Result［Fi［FU］］个 o: Busy［FU］个 No
\end{verbatim}
* FU 表示该指令使用的功能单元，D为目标寄存器名称，SI 和S2 为泳寄存器名称，op是要完成的操作。要
访问记分卡中名称为 F、针对功能单元 FU的项目，使用标记 FiFU］。ResudD］是将写入寄存器 D的功能
单元名称。当存在 WAR 冒险时，时写入结果情况的测试将禁止写入，如果另一条指令以这一指令的目标
寄存器（FIFU）为源寄存器（E1或FkJ），或者如果某一其他指令已经写入了寄存器（R-Yes或Rk=Ye8），
则存在 WAR冒險。时所有功能单元均使用变量。

记分卡的成本和收益也是人们的关注点。CDC 6600设计师测量到 FORTRAN序的
性能改进因数为1.7，对于人工编码的汇编语言改进因数为 2.5。但是，这些数据是在软
件流水线调度、半导体主存储器和缓存（缩短了存储器访问时间）之前的那一时期测得
的。CDC 6600上记分卡所拥有的逻辑数与一个功能单元相当，这是相当低的。主要成本
在于存在大量总线——其数量大约是 CPU 循序执行（或者每个执行周期仅启动一-条执
行）时所需数量的四倍。人们近来对动态调度的关注有所增加，其目的就是希望在每个
时钟周期内发射更多条指令（反正都要支付增加总线带来的成本），一些很自然地以动态
调度为基础的思想（比如4.7节研究的推测）也是提升此关注度的推动因素。

记分卡利用可用 ILP，在最大程度上降低因为程序真数据相关所导致的停顿数目。
在消除停顿方面，记分卡受以下几个因素的影晌。

\begin{enumerate}
    \item 指令间可用并行数—这一因素决定了能否找到要执行的独立指令。如果每条指
    令都依赖于它前面的指令，那就找不到减少停顿的动态调度方案。如果必须从同一基本
    模块中选择同时存在于流水线中的指令（在6600中就是如此），那这一限制是十分严重的。
    \item 记分卡的项数—这一因素决定了流水线为了查找不相关指令可以向前查找多少
    条指令。这组作为潜在执行对象的指令被称为窗口。记分卡的大小决定了窗口的大小。在
    这一节，我们假定窗口不会超过一个分支，所以窗口（及记分卡）总是包含来自单个基本
    模块的直行代码。第3章说明如何将窗口扩展到超出一个分支之外。
    \item 功能单元的数目和类型——这一因素决定了结构性冒险的重要性，它可能会在使
    用动态调度时增加。
    \item 存在反相关和输出相关——它们会导致WAR 和 WAW停顿。
\end{enumerate}

第3章重点研究了一些方法，用于解决在开发指令级并行（ILP）及更好地利用可用口LP时
出现的问题。第二个、第三个因素可以通过增加记分卡的大小及功能单元的数目来解决；但是，
这些改变可能会增加成本，还可能影响周期时间。WAW 和 WAR冒险在动态调度处理器中变得
更为重要，这是因为流水线暴露了更多的名称相关。如果我们使用采用分支预测方案的动态调
度，允许重叠执行一个循环的多个迭代，那么 WAW冒险也会变得更为重要。

\section{谬论与易犯错误}
\subsection{易犯错误 预料外的执行序列可能导致预料外的冒险。}
乍看起来，WAW 冒险似乎永远不可能在一个代码序列中出现，因为没有哪个编译器会生
成对同一寄存器的两次写人操作，却在中间没有读取操作，但当序列出乎意料之外时，却可能
发生WAW 冒险。例如，第一次写人操作可能在一个选中分支的延迟时隙中，而调度器认为该
分支未被选中。下面是可能导致这一情景的代码序列：

\begin{verbatim}
    BNEZ
    R1,f00
    DIV.D FO, F2,F4：从未被选中務入延退时際
    foo：
    L.D
    FO,9rs
\end{verbatim}
如果该分支被选中，则在DIV.D可以完成之前，L.D将到达WB，导致WAW冒险。硬件必须检
测这一冒险，并暂停发射L.D。另外一种可能发生这种情景的方式是第二次读取操作存在于陷
阱例程中。一条要写人结果的指令导致陷阱中断，当陷阱处理器中的一条指令完成对同一寄存
器的写人之后，原指令继续完成，这时就会发生上述情景。硬件也必须检测并阻止这一情景。
易犯错误 全面流水化可能影响到设计的其他方面，从而严重降低整体性价比。

\subsection{易犯错误 全⾯流⽔化可能影响到设计的其他⽅⾯，从⽽严重降低整体性价⽐}
这一现象的最佳示例来自 VAX 的两种实现——8600和8700。在8600最初交付时，其时钟
周期为 80ns。后来发布了一个名为8650的再设计版本，其时钟周期为55 ns。8700的流水线要
简单得多，工作在微指令级别，从而得到一个较小的CPU，其时钟更快，周期时间为45 ns。最
后的结果是：8650在CPI 方面具有大约20\%的优势，8700的时钟速率大约快20\%。因此，8700
以少得多的硬件实现了相同性能。

\subsection{易犯错误 根据未经优化的代码来评估动态或静态调度。}
与“严格”优化的代码相比，未经优化的代码（包括可以由优化器消除的冗余载人、存储
和其他操作）调度起来要容易得多。在调度控制延迟（带有延迟分支）和因为 RAW 冒险所导
致的延迟时也是如此。R3000拥有一个几乎与C.1 节相同的流水线，在R3000上运行的gcc中，
从未优化的调度后代码到经过优化的调度后代码，空闲时钟周期的频率提高18%。当然，优化
后的程序要快得多，因为其指令数较少。为了公平地评估编译时调度器或运行时动态调度，必
须使用优化代码，因为在实际系统中，除了调度之外，还会通过其他优化方法来提高性能。

\section{结语}
在20世纪80年代早期，流水线技术主要用于超级计算机和价值数百万美元的大型机。到
了 20世纪80年代中期，第一批流水线微处理器出现，推动了计算领域的转变，使微处理器在
性能上超过小型计算机，最终赶上和超过了大型机。到20世纪90年代早期，高端嵌人式微处
理器也采用了流水线，台式计算机首先开始使用第3章讨论的高级动态调度多发射方法。本附
录中的材料在20世纪90年代首先出现时，被认为对研究生来说也是相当高级的内容，现在被
看作是非常基础的本科生知识，可以在低于2美元处理器中找到相关应用。

\section{历史回顾与参考文献}
附录L.5 节讨论了流水线与指令级并行的开发，涵盖了本附录及第3章申的内容。我们提
供了大量参考文献，以便深人阅读和进一步研究这些主题。
练习（由Diana Franklin更新）
［15/15/15/15/25/10/15］<A.2>使用以下代码段：
\begin{verbatim}
    Loop：
    LD
    R1,0（R2）
    ；从地址 0+R2載入R1
    DADDI
    R1,R1，#1
    ；R1=R1+1
    sD
    R1.0，（R2）
    ；将R1 存储在 0+R2
    DADD！
    R2,R2，#4
    ；R2=R2+4
    DSUB
    RA.R3,R2
    ；R4=R3-R2
    BNEZ
    R4,Loop
    ；如果R4！=0则分支到循环
\end{verbatim}
假定R3的初始值为R2+396。
a. ［15］<C.2>数据冒险是由代码中的数据相关性导致的。相关性是否会导致冒险，取决于机器
实现（比如流水级的数自）。列出上述代码中的所有数据相关。记录寄存器、源指令和目标
指令：例如，从LD到 DADDI，存在对于寄存器 R1 的数据相关性。

b.［15］<C.2>给出这一指令序列对于5级RISC流水线的时序，该流水线没有任何转发或旁路硬
件，但假定在同一时钟周期中的寄存器读取与写人通过寄存器堆进行“转发”，如图C4所
示。请使用如表C-2中所示的流水线时序表。假定该分支是通过冲刷流水线来处理的。如果
所有存储器引用耗时1个周期，这一循环的执行需要多少个周期？

c.［15］<C.2>给出这一指令序列对于拥有完整转发、旁路硬件的5级 RISC 流水线的时序。请使
用如表C-2中所示的流水线时序表。假定在处理分支时，预测它未被选中。如果所有存储器
引用耗时1个周期，这一循环的执行需要多少个周期？

d. ［15］ <C.2>给出这一指令序列对于拥有完整转发、旁路硬件的5级 RISC流水线的时序。请使
用如表C-2中所示的流水线时序表。假定在处理分支时，预测它被选中。如果所有存储器引！
用耗时1个周期，这一循环的执行需要多少个周期？

e.［25］<C.2>高性能处理器拥有很深的流水线——超过15级。设想我们拥有一个10级流水线，
其中5级流水线的每一级被分为2级。唯一的难题是：对于数据转发操作，数据是由每一对
流水级的末尾转发到需要这些数据的两个流水线的开头。例如，数据从第二执行级的输出转
发到第一执行级的输人，仍然导致1个周期的延迟。对于一个拥有完整转发、旁路硬件的10
级 RISC 流水线，给出这一指令序列的时序。请使用如表C-2所示的流水线时序表。假定在
处理分支时，预测它被选中。如果所有存储器引用耗时1个周期，这一循环的执行需要多少
个周期？

f.［10］<C.2>假定在一个5级流水线中，最长的流水级需要0.8 ns，流水线寄存器延迟为0.1 nso
这个§级流水线的时钟周期时间为多少？如果10级流水线将所有流水级都分为两半，那么
10级机器的周期时间为多少呢？

g.［15］<C.2>利用第（d）、（e）部分的答案，判断该循环在5级流水线和10级流水线上的每指令間
期数（CPI）。确保仅计算从第一条指令到达写回级再到最后的周期数。不要计算第一条措令
的开始时间。利用第（fD部分计算的时钟周期数，计算每种机器的平均指令执行时间。
C.2

［15/15］<C.2>假定分支频率如下所示（以占全部指令的百分比表示）：
条件分支
15%
跳转与调用
1%
选中条件分支
60%被选中
a. ［15］ <C.2>我们正在研究一个深度为4的流水线，其中，无条件分支在第二間期结東时执行，
而条件分支则在第三个周期结束时执行。假定仅第个流水级总会完成，与是否执行该分支
无关，忽略其他流水线停顿，在没有分支冒险的情况下，该机器的速度快多少？
b. ［15］ <C.2>现在假定有一个高性能处理器，其中有一个深度为15的流水线，无条件分支在第
五周期结束时执行，条件分支在第十周期结束时执行。假定仅第一个流水级总会完成，与是
否执行该分支无关，忽略其他流水线停顿，在没有分支冒险的情况下，该机器的速度快多少？
C.3
［S/15/10/10］<C.2>我们首先考虑一个采用单周期实现的计算机。在按功能分割流水级时，这些
流水级需要的数目不一定相同。原机器的时钟周期时间为7ns。在流水线被分割之后，测得的
时间数据为：IF，I ns;LD,1.5 ns:EX,1 ns;MEM,2 ns; WB,1.5 ns。流水线寄存器延迟
为0.1nso
a. ［S］ <C.2>5级流水化机器的时钟周期时间为多少？
b.［15］<C.2>如果每4条指令有一次停顿，新机器的CPI 为多少？
c.［10］<C.2>流水化机器相对于单周期机器的加速比为多少？
d. ［10］<C.2>如果流水化机器有无限个流水级，那它相对于单周期机器的加速比为多少？
C.4［15］<C.1、C.2>典型5级RISC流水线的精简硬件实现可能使用EX级硬件来执行分支措令对比，
C-82
C-83
514
C-84
附录C 流水线：基础与中級概念
分支指令会在某一时钟周期而到达 MEM级，在此时钟周期之前，不会将分支目标 PC 实际提
交给正级。通过求解 ID中的分支指令可以缩减控制冒险停顿，但在某一方面的性能提升可能
会降低其他情况下的性能。写一小啓代码，在此代码中计算 \verb|_D| 级的分支时会导致数据冒险，甚
至在拥有数据转发时也是如此。
C.5
［12/13/20/20/15/15］<C.2、C.3>对于这些问题，我们将研究一种寄存器-存储器体系结构的流水
线。这一体系结构有两种指令格式：寄存器-寄存器格式和寄存器-存储器格式。存在一种单存
储器寻址方式（偏移量+基地寄存器）。还有一组采用以下格式的 ALU 运算：
ALUop Rdest, Rsrc1, Rsrc2
或
ALUop Rdest, Rsrcl, MEM
其中 ALUop 是以下指令之一：加、减、AND、OR、载人（忽略 Rsrc 1）或存備。Rsrc或Rdest
为寄存器。MEM 是基址寄存器和偏移量对。分支对两个寄存器进行全面对比，采用 PC相对寻
址。假定此机器实现了流水化，从而在每个时钟周期都会启动一条新措令。此流水线结构类似
于 VAX 8700微流水线中使用的结构［Clark 1987］，为：
RF ALU1 MEM WB
TF
RF ALU1 MEM ALU2 WB
IF
RF
ALU1 MEM
ALU2
WB
I
RF
ALU1
MEM
ALU2 WB
IF
RF
ALU1 MEM ALU2 WB
RF
ALUI MEM ALU2 WB
第一个 ALU流水级用于为存储器引用和分支的计算实际地址。第二个 ALU 周期用于运算和分
支比较。RF 既是解码周期也是寄存器提取周期。假定当在同一时钟周期对同一寄存器进行读取
和写人时，将转发所写数据。
a. ［12］ <C.2>求出所需加法器的个数，包括所有加法器和递增器；给出一组指令和流水级，证
明这一答案的合理性。只需要给出一种使加法器数目最大的组合方式。
b.［13］ <C.2>求出所需要的寄存器读、写端口数目以及存储器读、写端口。给出指令和流水级
的一种组合方式，以证明你的答案是正确的，要指出指令以及该指令所需要的读取端口和写
入端口。
c.［20］<C.3>判断任何 ALU所需要的数据转发。假定 ALU1和 AL.U2流水级拥有独立的ALU。
在 ALU之间放人为避免或减免停顿所需要的全部转发。以表C-12的形式，给出转发所涉及
的两条指令之间的关系，忽略表中最后两列。要仔细考虑跨越中间指令的转发，比如，
ADD
R1，…..
任意指令
ADD
⋯.R1，….
d. ［20］<C.3>当源单元或目标单元不是ALU时，给出为避免和减少停顿所需要的全部数据转发。
使用表C-12中的相同格式，再次忽略最后两列。别忘了向（自）存储器引用的转发。
e［15］<C.3>给出所有其他符合以下条件的冒险：至少有一个源单元或目标单元不是ALU。使
用表C-11所示的表格，但用冒险的长度来代替最后一列。
f.［15］ <C.2>以示例方式给出所有控制冒险，并列出停顿的长度。使用表C-4所示的格式，标
记出每个示例。
C.6 〔12/13/13/15/15］ <C.1、C.2、C.3>我们现在将向经典5级 RISC 流水线中添加对寄存器-存储器
ALU运算的支持。为了抵消复杂性的增长，所有存储器寻址都限于寄存器间接寻址（例如，所
有地址都只是保存在寄存器中的值；没有向寄存器值添加偏移量或位移）。例如，寄存器-存储
器指令 ADD R4,R5（R1）表示将寄存器R5的内容添加到某一存储器位置（其地址等于寄存器 R1
C.10
历史回顾与参考文献
515
中的值）的值，并将和值放到寄存器R4 中。寄存器-寄存器 ALU操作不变。以下各项适用于
整数 RISC流水线。
2.［12］<C.1>列出 RISC流水线五个传统流水级重新排列后的顺序，该流水线将支持由寄存器间
接寻址独占实现的寄存器-存储器操作。
b.［13］<C.2、C.3>给出重排序流水线需要哪些新转发路径，列出每条新路径的来源、目的地及
其上面传送的信息。
c.［13］<C.2、C.3>对于 RISC流水线重排序后的流水级，这种寻址模式生成了哪些新数据冒险？
给出一段指令序列，阐明每种新冒险。
d. ［15］<C.3>对于一个给定程序，与原 RISC流水线相比，拥有寄存器-存储器ALU运算的RISC
流水线的指令数可能不同，列出所有这些差别。给出一对特定的指令序列，一个用于原流水
线，一个用于重新排序后的流水线，以说明每种差别方式。
e.［15］<C.3>假定所有指令在每个流水线上花费1个时钟周期。与原RISC流水线相比，寄存器-
存储器RISC对一个给定程序的CPI 可能会有所不同，列出所有这些差别。
C.7
［10/10］<C.3>在这个问题中，我们将研究流水线的加深如何以两种不同方式来影响性能：加快
时钟周期，因为数据与控制冒险而延长停顿。假定原机器是一个5级流水线，其时钟眉期为1ns。
第二种机器为12级流水线，时钟周期为 0.6 ns。由于数据冒险，5级流水线每5条指令经历1
次停顿，而12级流水线每8条指令经历3次停顿。此外，分支占全部指令的20%，两台机器的
错误预测率都是5%。
a.［10］<C.3>仅考虑数据冒险，12级流水线相对于5级流水线的加速比为多少？
b.［10］<C.3>如果第一台机器的分支错误预测代价为2个周期，而第二台机器为5个周期，则
每种机器的CPI为多少？由于分支错误预测而导致的停顿考思在内。
C.8
\begin{verbatim}
    ［I5］<C.$>绘制一个表格，采用表C-12所示的格式，说明R4000 整数流水线的转发逻辑。仅包
    含我们在表C-12中考虑的MIPS指令。
    C.9
    ［LS］ <C.5>绘制一个表格，采用表C-11所示的格式，说明R4000 整数冒险检测。仅包含我们在
    表C-12中考虑的MIPS指令。
    C.10［25］<C.5>假定 MIPS仅有一个寄存器组。使用表C-12的格式，构造浮点和整数指令的转发表。
    忽略浮点除法与整数除法。
    C.11 ［15］ <C.5>构造一个类似于如表C-11所示的表格，检查图C-18中 MIPS浮点流水线中的WAW
    停顿。不考思浮点除法。
    C.12
\end{verbatim}
［20/22/22］<C.4、C.6>在这个练习中，我们将研究一个常见向量循环如何在 MIIPS 流水线的静态、
动态调度版本上运行。这个循环就是所谓的 DAXPY循环（在附录G中进行了全面讨论），它
是高斯消去法中的核心运算。该循环对于一个长度为100的向量实现了向量运算 Y=a*X+Y。下
面是该循环的 MIPS 代码：
\begin{verbatim}
    foo：
    L.D
    F2,0（R1）
    ；載入XCi）
    MUL..D
    F4, F2, FO
    ；求梨积a*X（i）
    L.D
    F6,0（$2）
    ；載入Y（i）
    ADD.D
    F6, F4,F6
    ；求和a*X（i）+Y（i）
    $.D
    0（R2），F6
    ；存储YCi）
    DADDIU
    R1,R1，#8
    ；递增X索引
    DADDIU
    R2,R2，#8
    ；递增丫索引
    SGTIU
    R3, R1,done
    ；测试是否完成
    BEQZ
    R3,f00
\end{verbatim}
；如果没有完成别继续精环
对于第（a）部分至第（c）部分，假定整数运算在一个时钟周期内发射和完成（包括载人如它们的
结果被完全旁路。忽略分支延迟。（仅）使用表C-17所示的浮点延迟，但假定浮点单
被完全
流水化。对于以下记分卡，假定一个等待另一功能单元结果的指令可以在写人该结果的同时读
取操作数。另外假定一个指令正在执行 WR，它允许在自己执行 WR的同一时钟局期内
穷
C85
©-8g
516
C-87
附录C 流水线：基础与中級概念
外一条指令，而所发射的这一措令可以与正在执行 WR的指令等待同一功能单元。
2.［201<C.5>对于这个问题，使用C.S节的 MIIPS 流水线，其流水线延迟如表C-17所示，但浮
点单元实现了完全流水化，所以启动间隔为1。画出与表C-19类似的时序图，显示每条指令
的执行时序。每个循环迭代耗用多少个时钟周期？从第一条指令进人WB级开始计算，直到
最后一条指令进人 WB级为止。
b.［22］ <C.6~使用上面 DAXPY的MIPS代码，给出当 SGTTU指令到达写结果阶段时记分卡表
的状态（如表C-31 所示）。假定发射和读取操作数各需要1个周期。假定有一个整数功能
单元仅需要一个执行周期（延迟为0个周期，包括载人和存储）。假定采用图C-25 的浮点
单元配置，其浮点延退如表C-17所示。该分支不应包含在记分卡中。
c.［22］<C.6>使用上面 DAXPY的MIPS代码，假定一个记分卡具有图C-25所述的浮点功能单
元，再加上一个整数功能单元（也用于载人-存储）。假定延迟如表C-34所示。给出第二次
分支发射时的记分卡状态（如表C-31所示）。假定分支被正确预测为选中，耗时1个周期。
每次循环选代需要多少个时钟周期？可以忽略所有寄存器端口/总线冲突。
表C-34 流水线延迟（其中延迟用时钟周期数表示）
生成结果的指令
使用结果的指令
延迟（单位：时钟周期）
浮点乘
浮点ALU操作
6
浮点加
浮点ALU操作
4
浮点乘
浮点存储
浮点加
浮点存储
整数运算（包括载入）
任意
3
0
C.13［25］ <C.8>由于 WAR冒险需要暂停正在执行写人的指令，直到读取指令的指令开始执行为止，
而RAW冒险需要延迟正在进行读取的指令，直到正在进行写人的指令完成为止，正好与 WAR
冒险相反，因此，记分卡能够区分RAW和WAR冒险是非常重要的。例如，考虑以下序列：
MUL.D
F0,F6,F4
DSUB.D
F8,F0, F2
ADD.D
F2,F10,F2
DSUB.D依赖于 MUL.D（一次 RAW冒险），因此，必须允许MUL.D在DSUB.D之前完成。如果由
于不能区别RAW 和 WAR 冒险，MUL.D因为DSUB.D而停顿，处理器将会死锁。这一序列包含
A0D.0与 DSUB.D之间的WAR冒险，在DSUB.D开始执行之前，不允许ADD.D完成。难度在于区
分MUL.D和 DSUB.D之间的RAW冒险和DSUB.D和ADD.D之间的WAR冒险。为了明白为什么三
指令情景非常重要，逐级跟踪每条指令的处理：发射、读取操作数、执行和写结果。個定 MUL.D
指令需要 3个时钟周期来执行，DSUB.D和 ADD.D指令各需要1个周期来执行。最后，假定处理
器有两个乘法功能单元和两个加法功能单元。给出跟踪过程如下。
（1）制作一张表，各列的标题分别为：指令、发射、读取操作数、执行、写结果、备注。在第一
列中，按程序顺序列出这些指令（指令之间留出足够的空间，表格的单元格越大，越容易保
存分析结果）。首先在 MUL.D指令列的“发射”列中写下1，表明 MUL.D 在时钟周期1申完
成发射级。现在，填充表中各个流水级列，直到记分卡首次暂停一条指令的周期为止。
（2） 对于停顿指令，在适当的表列中写下如下文字“在时钟周期X等待”，其中X是当前时钟
周期的编号，以表明该记分卡正在通过停顿该流水级来解决RAW或WAR 冒险。在“备注”
列中，写出是哪种类型的冒险和哪个相关指令导致等待。
（3） 向“正在等待”的表项添加文字“在时钟周期Y完成”，填充表中其余各项，直到所有指
令完成为止。对于一条被暂停的指令，在“备注”列中添加一项备注，说明该等待为什么结
C.10 历史回顾与参考文献
517
束以及如何避免死锁。（提示：考虑一一下如何避免WAW冒險，以及它对活动指令序列意味
着什么。）注意，三条指令的完成顺序与其程序顺序的对比。
C.14［10/10/10］<C.5>在这个问题中，需要编写一系列短小代码，说明在使用具有不同延迟的功能单
元时所导致的发射。对于每个代码段，画出与表C-20类似的时序表，说明每个概念，明确指出
问题所在。
a. ［10］ <C.5>展示当硬件中仅有一个 MEM 和 WB 级时的结构性冒险，所使用的代码应当不同
于表C-20中使用的代码。
b.［10］<C.5>展示需要停顿的 WAW冒险。
©-88