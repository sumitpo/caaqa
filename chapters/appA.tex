
\chapter{指令集基本原理}
An 将存储位置n中的数字加到累加器中。
En 如果果加器中的数字大于或等于零，则执行位于存储
位置n的命令；否则顺序执行。
Z 停止运行计算机，并发出警告铃声。
—Wilkes 和 Renwick，
选自 EDSAC的18 条机器指令列表（1949）

\section{引言}
本附录主要介绍指令集体系结构—程序员或编译器编写人员能够看到的计算机部分。对
于本书读者来说，这一材料中的大多数内容应当都是一种回顾；我们主要作为背景知识提供这
些内容。本附录中介绍了指令集体系结构的各种设计选项。具体来说，我们主要关注四个主题。
第一，对各种指令集进行了分类，并对各种方法的优势和劣势进行某种量化评估。第二，给出
一些指令集测量数据，并对其进行分析，这些数据大体与特定的指令集无关。第三，讨论语言
与编译器问题以及它们对指令集体系结构的影响。最后，“融会贯通”一节展示这些思想如何在
MIPS 指令集中得到反映，MIPS指令集是一种典型的RISC体系结构。在附录的末尾是有关指
令集设计的一些谬论和易犯错误。

为了进一步说明这些基本原理，附录K还给出了4种通用 RISC体系结构的例子（MIPS、
PowerPC、Precision Architecture、SPARC）、4种嵌人式 RISC处理器示例（ARM、Hitachi SH、
MIPS 16、Thub） 和3种较早的体系结构（80x86、IBM 360/370和 VAX）。在讨论如何对体系
结构分类之前，需要先来谈谈指令集的测量。

在这个附录中，我们将研究大量体系结构方面的测试结果。显然，这些测量结果依赖于被
测程序和用于进行这些测量的编译器。这些结果不应被认为是绝对的，如果用不同编译器或一
组不同程序来进行测试，那可能会得到不同数据。我们相信本附录给出的测量值可以合理地代
表一类典型的应用程序。许多测量是使用一小组基准测试给出的，以便适度地显示数据，并可
能看出程序之间的差别。架构师在设计新计算机时，可能希望预先分析大量程序，再来作出体
系结构方面的决策。所示测量通常是动态的——对一个被测事件的频率进行了加权，权重就是
这一事件在被测程序执行期间出现的次数。

在开始讨论一般性基本原理之前，先来回顾一下第1章介绍过的三种应用领域。桌面式计
算强调涉及整数、浮点类型的程序的性能，很少考虑程序的规模。例如，在五代 SPEC 基准测
试中从来没有报告过代码规模。今天的服务景主要用于数据库、文件服务器和Web 应用程序，
再加上一些针对许多用户的时分应用程序。因此，浮点性能的重要性要远低于整数与字符字符
串的重要性，不过几乎所有服务器处理器都仍然包含浮点指令。个人移动设备和嵌入式应用看
重成本和能耗，所以代码规模非常重要，这是因为减少存储器就意味着可以降低价格和能耗，
为了降低芯片成本，某些类型的指令（比如浮点）可能成为可选选项。

因此，所有这三种应用的指令集都是非常类似的。事实上，作为本附录主体内容的 MIPS
体系结构已经成功地运用在台式机、服务器和嵌入式应用中。

一种与 RISC有很大不同的成功体系结构是 80x86（参见附录K）。令人惊奇的是，它的成
功并不一定与RISC指令集的优势相矛盾。由于与PC软件保持二进制兼容的重要性，再加上摩
尔定律提供了充足的晶体管，使 Intel在内部使用 RISC指令集，而在外部支持80x86 指令集。
后来的80x86微处理器（比如 Pentium 4）使用硬件将 80x86指令转换为类 RISC的指令，然后
在芯片内部执行经过转换的操作。它们仍然向程序员展现 80x86体系结构的幻像，同时允许计
算机设计人员实现RISC类型的处理器，以提高性能。

既然已经确定了背景，现在可以开始研究如何对指令集体系结构进行分类了。

\section{指令集体系结构的分类}
处理器中的内部存储类型是最基本的区别，所以在这一节，我们将主要关注体系结构中这
一部分的各种选项。主要选项包括栈、累加器或寄存器组。操作数可以显式命名，也可以隐式
命名：在栈体系结构中，操作数隐式位于栈的顶部，而在暴加器体系结构中，操作数隐式为累
加器。通用寄存器体系结构只有显式操作数，或者为寄存器，或者为存储器位置。图A-1 显示
了此类体系结构的框图，表A-1显示了代码序列C-A+B在这三类指令集中通常是如何显示的。
显式操作数也许可以直接从存储器访问，也可能需要首先加载到临时存储中，具体取决于体系
结构的类别及特定指令的选择。

图A-1 4类指令集体系结构的操作数位置。这些箭头指示操作数是算术逻辑单元（ALU）操作的输入还
是结果，或者既是输人又是结果。较浅的阴影表示输人，深色阴影表示结果。在（a）中，栈顶寄存
器（TOS）指向顶部输入操作数，它与下面的操作数合并在一起。第一个操作数从栈中移走，结果
占据第二个操作数的位置，对TOS进行更新，以指向结果值。所有操作数都是隐式的。在（b）中，
累加器既是隐式输人操作数，也是结果。在（c）中，一个输入操作数是寄存器，一个在存储器中，
结果保存在寄存器中。在（d）中，所有操作数都是寄存器，而且和栈体系结构类似，只能通过独立
指令将其传送到存储器中：在（a）中为 push 或 pop，在（d中为 load或 store

表A-1 四类指令集中C-A+B的代码序列
\begin{verbatim}
    栈
    累加骼
    寄存影（寄存器-存储器）
    Push A
    Load A
    Load RI.A
    Load R1. A
    Push B
    Add B
    Add R3. R1,B
    Load R2. B
    Add
    Store C
    Store R3.C
    Add R3. R1.R2
    Pop C
    Store R3, C
\end{verbatim}
*注意，村于栈和累加器体系结构，Add指令拥有隐式操作教，对于寄存器体系结构拥有显式操作教。假定A、B和C
都属于存储器，A和B的值不能被销毁。困A-1显示了针对每类体系结构的 Add 运算。

如上面的图和表所示，实际上有两种类型的寄存器计算机。一类可以用任意指令来访问存
储器，称为寄存器-存储器体系结构，另一类则只能用载人和存储指令来访问存储器，称为载入
-存储体系结构。第三类（还没有出现在今天交付的计算机中）将所有操作数都保存在存储器中，
称为存储器-存储器体系结构。一些指令集体系结构的寄存器要多于单个累加器，但对这些特
寄存器的使用设置了一些限制。此类体系结构有时被称为扩展累加器或专用寄存器计算机。

尽管大多数早期计算机都使用栈或累加器类型的体系结构，但在1980年之后的几乎所有新
体系结构都使用了载入-存储寄存器体系结构。通用寄存器（GPR）计算机之所以会出现，其主
要原因有两个。第一，寄存器（类似于处理器内部其他形式的存储器）快于存储器。第二，对
编译器来说，使用寄存器要比使用其他内部存储形式的效率更高。例奶，在寄存器计算机中，
在对表达式（AXB）- （BXC）- （AXD）求值时，可以按任意顺序执行乘法计算，这种做法的效率
更高一些，可能是操作数位置的原因，也可能是流水线因素的原因（见第3章）。不过，在栈计
算机上，硬件只能按唯一的顺序对表达式进行求值，这是因为操作数是隐藏在栈中的，它必须
多次载人操作数。

更重要的是，寄存器可用于保存变量。当变量被分配到寄存器中时，可以降低存储器通信
流量、加快程序速度（由于寄存器的速度快于存储器），提高代码密度（由于寄存器的名称位数
少于存储器位置的名称位数）。

在 A.8节将会解释，编译器编写人员希望所有寄存器都是等价的、无保留的。较早的计算
机在满足这•期望方面打了折扣，将一些寄存器专门用于一些特殊应用，显著降低了通用寄存
器的数量。如果真正通用寄存器的数目过小，那尝试将变量分配到寄存器中就没有什么好处。
编译器将所有未确认用途的寄存器保留给表达式求值使用。

有多少个寄存器才是足够的呢？其答案当然取决于编译器的有效性。大多数编译器会为表
达式求值保留一些寄存器，为参数传递使用一些，其余寄存器可用于保存变量。现代编译器技
术能够有效地使用大量寄存器，从而增加了最新体系结构的寄存器数目。

有两个重要指令集特性可以用来区分 GPR体系结构。这两个特性都关注一个典型算术或逻
辑指令（ALU 指令）操作的本质。第一个特性关注一个 ALU 指令是有两个还是三个操作数。
在三操作数格式中，指令包含一个结果操作数和两个源操作数。在两操作数格式中，操作数之
一既是运算的源操作数，又是运算的结果操作数。GPR 体系结构的第二个区别是考虑 ALU 指
令中可能有多少个操作数是存储器地址。一个典型 ALU指令所支持的存储器操作数数量可以是
0~3个。表A-2给出了这两种特性的组合及其计算机示例。尽管共有7种可能组合方式，但其
中3种就可以对几乎全部现有计算机进行分类。前面曾经提到，这3种是载入-存储（也称为寄
存器 寄存器）、寄存器-存储器和存储器-存储器。

表A-2 存储器操作数与每条典型ALU指令中总操作数的典型组合方式，并给出计算机示例
存储謂地址的数目
所允许的最大操作数个数
体系结构的类型
示例
0
3
藏入-存储
Alpha、ARM、MIPS、PoWEPC、SPARC、
SuperHi、TM32
1
2
寄存器-存储器
IBM 360/370、Intel 80x86、Motorola 68000、
TI TMS320C54x
2
3
2
3
存储器-存储器
VAX（还有三操作数格式）
存储器-存储器
VAX（还有两操作数格式）

•ALU 捐令中没有存储器引用的计算机称为載入-存储或寄存器-寄存露计算机。每系典型 ALU 指令中有多个存储器操
作数的指令称力寄存器-存储嚣或存储器-存储器，具体取决于它们是拥有一个还是一个以上的存储器操作教。

表A-3显示了每一类型的优势和劣势。当然，这些优势和劣势不是绝对的：它们是定性的，
它们的实际影响取决于编译器和实现策略。采用存储器-存储器运算的GPR 计算机很容易被编
译器忽略，用作一种载人-存储计算机。体系结构方面最普遍的影响之一是对指令编码和执行一
项任务所需指令数的影响。在附录C和第3章中可以了解这些不同体系结构对实现方法的影响。

A-S
表A-3 3种最常见通用寄存计算机的优势和劣势
类型
优势
劣势
寄存器-寄存器
简单、固定长度指令编码。简单代码生成模型。 措令数目高于指令中有存储器引用的体系结构。
（0,3）
指令执行所需要的时钟数相似（参见附录C）
措令多、指令密度低，增大了程序的規模
寄存器-存储器
无需独立的载入指令就可以访问数据。指令格
由于在二元运算中，源操作数会被销毁，所以操
（1,2）
式易于编码，可以得到很好的指令密度
作数是不等价的。在每条指令中对寄存器数目和
存储器地址进行编码可能会限制寄存器的个数。
每条指令的时钟数会随操作数的位置变化
存储器-存储器 最紧凑。没有为临时值浪费寄存器
（2,2）或（3,3）
指令规模变化很大，特别是对于三操作数指令。
此外，每条指令的工作也有很大变化。存储器访
同会造成存储器瓶颈（现在未使用）


*符号（m.j）表示存储器操作数有m个，共有n个操作数。一般来说，可选项較少的计算机简化了编译的任务，因
为编译群需要作出的决策较少（见 A.8节）。具有大量灵活指令格式的计算机減少了程序编码需要的位数。寄存嚣
的教目对指令大小也有所影响，因为对于指令中的每个寄存器分类符，需要1oB（寄存器个数）。因此，时于寄存器-
寄存器体系结构而言，寄存器个数加倍需叠增加3个位，大约是32位指令的10%。

小结：指令集体系结构分类
在这里和 A.3节到 A.8节的末尾，我们总结了希望在新指令集体系结构中出现的特性，为
A.9 节介绍的 MIPS体系结构奠定基础。从这一节开始，我们应当期待通用寄存器的使用。表
A-3 再结合关于流水线的附录C，给出了关于通用寄存器体系结构载人-存储版本的一些展望。
在介绍了体系结构分类之后，下一个主题将介绍操作数。

\section{存储器寻址}

一个体系结构，无论是载入-存储式，还是允许任何操作数都是存储器引用，它都必须定义
如何解释存储器地址以及如何指定这些地址。这里给出的测量值大体与计算机无关，但并非绝
对如此。在某些情况下，这些测量值受编译器技术的影响很大。由于编译器技术扮演着至关重
要的角色，所以这些测量都是使用一种优化编译器测得的。

\subsection{解释存储器地址}
如何解释一个存储器地址呢？也就是说，根据地址和长度会访问到什么对象呢？本书中讨
论的所有指令集都是字节寻址的，提供对字节（8位）、半宇（16位）和字（32位）的访问方式。
大多数计算机还提供了对双字（64位）的访问。

关于如何对一个较大对象中的字节进行排序，有两种不同的约定方式。小端字节顺序将地
址为“x..x000”的字节放在双字的最低有效位置（小端）。字节的编号为：

大端字节顺序将地址为“x..x000”的字节放在双字的最高有效位置（大端）。字节的编号为：

在同一台计算机内部进行操作时，字节顺序通常不会引起人们的注意——只有那些将相同
位置同时作为字和字节进行访问的程序才会注意到这一区别。但是，在采用不同排序方式的计
算机之间交换数据时，字节顺序就会成为一个问题。在对比字符串时，小端排序也不能与字的
正常排序方式相匹配。宇符串在寄存器中是反向表示的，如backwards 显示为“SDRAWKCAB”。

第二个存储器问题是：在许多计算机中，对大于一字节的对象进行寻址时都必须是对齐的。
大小为s字节的对象，字节地址为A，如果4mods-0，则对该对象的寻址是对齐的。图A-2显
示了寻址为对齐和不对齐时的地址。

图A-2 在字节寻址计算机中，宇节、半宇、宇和双宇对象的对齐与未对齐地址。对于每种未对齐示例，
一些对象需要两次存储器访问才能完成。每个对齐对象总是可以在一次存储器访阿中完成，只要
存储器与对象的宽度相同即可。本图显示的存储器宽度为8个字节。标记各列的字节偏移指定了
该地址的低3位

.为什么有人要设计一种带有对齐限制的计算机呢？由于存储器通常与一个字或双字的倍数
边界对齐，所以非对齐寻址会增加硬件复杂性。一个非对齐存储器寻址可能需要多个对齐的存储
器引用。因此，即使在允许非对齐寻址的计算机中，采用对齐寻址的程序也可以运行得更快醬。
即使数据是对齐的，要支持字节、半字和字寻址也需要—一个对齐网络来对齐64位寄存器中
的字节、半字和字。例如，在表A-4中，假定从低3位取值为4的地址中读取一个字节。我们
需要右移3个字节，对准64位寄存器中正确位置的字节。根据具体指令，计算机可能还需要对
这个量进行符号扩展。存储过程很容易：只有存储器的寻址字节可被修改。在某些计算机中，
字节、半字和字操作不会影响到寄存器的上半部分。尽管本书中讨论的所有计算机都允许对存
储器进行字节、半字和字访问，但只有 LBM 360/370、Intel 80x86 和 VAX支持对不足完整宽度
的寄存器操作数进行 ALU运算。

既然已经讨论了存储器寻址的各种解释方法，现在可以讨论指令用来指定地址的方式了，
这些方式称为寻址方式。

\subsection{寻址方式}
给定地址后，我们就知道了去访问存储器的哪些字节。在这一小节中，我们将研究寻址方
式—体系结构如何指定要访问对象的地址。除了存储器中的位置之外，寻址方式还指定常量
和寄存器。在使用存储器位置时，由寻址方式指定的实际存储器地址称为有效地址。

表A4显示了在最近计算机中用到的所有数据寻址方式。立即数或直接操作数寻址通常被看
作存储器寻址模式（即使它们访问的值位于指令流中也是如此），不过，由于寄存器通常没有存储
器地址，所以我们将它们分离出来。我们已经将那些依赖于程序计数器的寻址模式（称为PC 相对
寻址）分离出来。PC相对寻址主要用于在控制转移指令中指定代码地址，A.6节将对此进行讨论。
\begin{verbatim}
    表A-4
    寻址方式的选择，并给出示例、含义及用法
    寻址方式
    指令举例
    含义
    使用时机
    寄存器寻址
    Add R4,R3
    Regs［R4］ Regs［R4］+ Regs［R3］
    当一个值在寄存器中
    立即数寻址
    Add R4.#3
    Regs［R4］1 Regs［R4］+3
    对于常量
    位移谶寻址
    Add RA,100（RI）
    Regs［R4］ - Regs［R4］+ Mem［100
    访问本地变量（+模拟寄存器间
    + RegS［R1］］
    接、直接寻址方式）
    寄存器间接寻址
    Add R4.（R1）
    Regs［R4］ - Regs［R4］
    使用指针或计算得出的地址寻址
    + Mem［Regs［R1］］
    索引寻址
    Add R3， （RI + R2）
    Regs［R3］ 1 Regs［R3］
    有时用于数组寻址：R1为数组的
    + Mem ［Regs［R1］+ Regs［R2］］
    基址，R2为索引值
    直接或绝对寻址
    Add R1.（1001）
    Regs［R1］ - Regs［R1］
    有时用于访问静态数据；地址常
    + Mem［1001］
    量可能很大
    存储器间接寻址
    Add R1.@（R3）
    Regs［R1］ 1 RegsTRI］
    如果R3为指针p的地址，则此方
    + Mem ［Mem ［Regs［R3］］］
    式生成*p
    自动递增寻址
    Add R1， （R2）+
    Regs［R1］ - Regs［R1］
    用于在循环内部逐步遍历数组。
    + Mem［Regs［R2］］
    R2指向数组的开始位置；每次引
    Regs［R2］ - Regs［R2］+d
    用时都会将R2的值增大一个元
    素的大小d
    自动递减寻址
    Add RI， -（R2）
    Regs［R2］ 1 Regs［R2］-d
    与自动递增的用途相同。自动递
    Regs［R1］ - Regs［R1］
    增/递滅也可以用作push/pop，以
    + Mem［Regs［R2］］
    实现栈
    比例寻址
    Add R1,100（R2）［R3］
    Regs［R1］ f Regs［R1］+ Mem［100
    用于索引数組。在某些计算机
    + Regs［R2］+ Regs［R3］* d
    中，可用于任何紫引寻址方式
\end{verbatim}
• 在自动邋增/遵减和比例寻址方式中，变量d指定所访问数据项的大小（即，该指令访问的是1、2、4或8宇节中的
哪一种）。只有当被访问元素位于存储露中的连续位置时，这些寻址方式才有用。RISC计算机使用位移量寻址来模
拟寄存器间接寻址（地址沟O）和直接哥址（基址寄存器中为 O）。在我们的测量结果中，使用汋每种模式運示的第
一个名称。在 A.9.5节定义了用作硬件描述的C语言扩展。

表A-4给出了这些寻址方式的最常见名称，当然，这些名称在不同体系结构中是有差别的。

在本表及整本书中，我们将使用C编程语言的扩展作为硬件描述符号。在本表中，只使用了一
个非C特征：用左箭头（一）表示赋值。我们还使用数组 Men 作为主存储器的名称，使用数组
Regs 表示寄存器。因此，Mem［Regs［R1］］是指存储器位置的内容，这一位置的地址由寄存器1（R1）
的内容给出。对于小于一个字的数据，我们将在后面介绍用于访同和转移此类数据的扩展。

寻址模式能够大幅减少指令数目，它们也会增加构建计算机的复杂度，对于实施这些方式
的计算机，还可能增加每条指令的平均时钟周期数目（CPI）。因此，各种寻址模式的使用对于
帮助架构师选择包含哪些功能是十分重要的。

图 A-3 中给出在VAX体系结构上对3个程序中寻址方式使用样式的测量结果。在这个附录
中，我们使用较旧的VAX体系结构进行一些测量，这是因为它拥有最丰富的寻址方式，对存備
器寻址的限制最少。例如，表A-2给出了 VAX支持的所有方式。但是，本附录中的大多数测量
将使用最近的寄存器-寄存器体系结构，以显示程序如何使用当前计算机的指令集。

图A-3 存储器寻址方式（包括立即数）的用法小结。几乎所有存储器访问都采用这几种主要寻址方式（可
能只有0%~3%的例外）。一半的操作数引用采用寄存器寻址方式（没有计算在前面的比例之中），
而另一半则采用存储器寻址方式（包括立即数）。当然，编译器会影响到选用哪种寻址模式；参见
A.8节。VAX上的存储暑间接寻址方式可使用位移量、自动递增或自动递减来形成初始存储器地
址；在这些程序中，几乎所有存储器间接引用都以位移量寻址方式为基准方式。位移量寻址方式
包括了所有位移量长度（8、16和32位）。PC相关寻址方式（几乎专用于分支）未包含在内。图
中仅给出了平均使用频率超过1%的寻址方式

如图 A-3所示，位移量寻址和立即数寻址成为主导寻址方式。让我们来看看这两种广泛应
用的寻址方式的一些特性。

\subsection{位移量寻址方式}
在使用位移量类型的寻址方式时，一个主要问题就是所用位移量的范围。根据所使用的各
种位移量大小，可以决定支持哪些位移量大小。由于位移量字段的大小直接影响到指令的长度，
所以其选择非常重要。图A4是利用基准测试程序对载入-存储体系结构中数据访问进行的测量
结果。我们将在 A.6 节研究分支偏移—数据访问样式与分支是不同的；将它们两者结合起来
并没有什么收益，但在实际中，为简单起见，一般会使立即数的大小相同。

图 A-4 位移值的分布非常广泛。既存在大量小数值，又有相当数量的大数值。位移值的广泛分布是由于
变量有多个存储区域，而且访问它们的位移量不同（见A.8节），而且编译器使用的总寻址机制也
各不相同。x轴是位移量以2为底的对数值，即表示该位移量所需要的字节大小。x轴上的零表示
位移值0的百分比。该曲线没有包含符号位，存储布局对它会有严重影响。大多数位移值是正数，
但最大的位移值（14位以上）为负值。由于这些数据是在一个采用16位位移量的计算机上收集
的，所以无法从中了解更长位移量的信息。这些数据是在 Alpha 体系结构上测得的，对 SPEC
CPU2000 进行了全面优化（见 A.8节），给出了整数程序（CINT2000）的平均值和浮点程序
（CFP2000）的平均值

\subsection{立即数或直接操作数寻址方式}
在进行算术运算、比较（主要用于分支）和移动时，如果希望将常量放在寄存器中，可以使
用立即数。后一种情景可用于写在代码中的常量（这种常量较小）和地址常量（这种常量可能很
大）。对于立即数的使用，重点是要知道是需要对所有运算都支持立即数，还是仅对一部分运算
支持立即数。图A-S显示了在一个指令集中，立即数在一般类型的整数和浮点运算中的使用频率。

图A-5 大约有四分之一的数据传送和 ALU 运算拥有立即操作数。下面的长条表示整数程序在大约五分之
一的指令中使用立即数，而浮点程序在大约六分之一的指令中使用立即数。对于载人操作，载人
立即数指令将16位载入一个32位寄存器的任一半中。载人立即数并不是严格意义上的载入，因
为它们并不访问存储器。偶尔会使用一对载入立即数来载人32位常量，但这种情况很少见。（对
于 ALU运算，还包含移动常数位，作为带有立即操作数的运算。）用于收集这些统计数字的程序
和计算机与图 A-4相同

另一个重要指令集测量是立即数的取值范围。与位移值相似，立即数取值的大小也影响到
指令长度。如图A-6所示，小立即数的应用最多。不过，有时也会使用大型立即数，更多的是
用在地址计算中。

图A-6 立即数值的分布。x轴给出表示立即值取值大小所需要的位数一—0表示立即数字段值为0。大多
数立即数取值为正数。对于 CINT2000，大约20%为负数，对于 CFP2000，大约30%为负数。这
些测量是在 Alpha 上执行的，其中最大立即数为16位，被测程序与图A-4中相同。对VAX进行
的类似测量（它支持32位立即数）表明：大约20%~25%的立即数长于16位。因此，16位的长度
覆盖大约80%，8位可以覆盖大約50%

\subsection{小结：存储暑寻址}
首先，我们预测一种新的体系结构至少支持以下寻址方式：位移量寻址、立即数寻址和寄
存器间接寻址，这主要是因为它们非常普及。图A-3显示它们代表了我们测量中所使用的
75%~99%的寻址方式。其次，我们预测位移量寻址方式中的地址大小至少为12~16位，根据图
A-4 的图题，这些大小将占到位移量的75%~99%。最后，我们预测立即数字段的大小至少
8~16位。这一说法在它提到的图题中没有得到证实。

我们已经介绍了指令集分类并决定采用寄存器-寄存器体系结构，再加上前面关于数据寻址
模式的建议，下面将介绍数据的大小与意义。

\section{操作数的类型与大小}

如何指定操作数的类型呢？通常，通过在操作码中进行编码来指定操作数的类型——这是
最常用的方法。或者，用一些可以被硬件解读的标签对数据进行标记。这些标签指定操作数的
类型，并相应选择操作。但是，带有标记数据的计算机只能在计算机博物馆里找到了。
我们首先从台式机和服务器体系结构开始。通常，操作数的类型（整数、单精度浮点、字
符等）有效地确定了其大小。常见操作数类型包括字符（8位）、半字（16位）、宇（32位）、单
精度浮点（也是1个字）和双精度浮点（2个字）。整数几乎都是用二进制补码数字表示的。字
符通常用 ASCI表示，但随着计算机的国际化，16位Unicode（在Java 中使用）也正在普及。
直到20世纪80年代早期，大多数计算机制造商还在选择自己的浮点表示法。从那之后，几乎
所有的计算机都遵循了相同的浮点标准，IBEE标准754。IEEE浮点标准在附录J中详细讨论。

一些体系结构提供了对字符串的操作，不过这些操作通常都十分有限，将字符串中的每个
字符都看作单个字符。支持对字符串执行的典型操作包括比较和移动。

对于商务应用程序，一些体系结构支持二进制格式，通常称为压缩十进制或二进制编码十
进制—一用4个位对0至9的数值进行编码，两个十进制数位被压缩到两个字节中。数值字符
串有时称为非压缩十进制，通常提供在被称为压缩和解压缩的操作之间来回转换。

使用十进制操作数的一个理由是获得与二进制数字完全匹配的结果，这是因为一些十进制
小数无法用二进制准确表示。例如，0.10在十进制中是一个很简单的小数，但在二进制中，它
需要无限个重复数位来表示：0.0001100110011•20 因此，十进制中的准确计算在二进制中可
能十分接近但并非完全准确，对于金融事务，这可能会成为一个问题。（如需了解有关精确算术
的更多知识，请参阅附录J。）

我们的 SPEC 基准测试使用字节或字符、半字（短整数）、字（整数）、双字（长整数）和
浮点数据类型。图A-7给出了为这些程序引用存储器对象的大小动态分布。对不同数据类型的
访问频率有助于确定哪些类型最为重要，应当加以高效支持。计算机是否应当拥有64位访问路
径，或者用两个时钟周期来访问一个双字是否可行？我们前面曾经看到，字节访问需要一个对
齐网络：将字节作为基元类型提供支持有多么重要？图A-7使用存储器引用来查看被访问数据
的类型。

图A-7 对于基准测试程序，所访问数据的大小分布。双字数据类型用于表示浮点程序中的双精度浮点值，
还用于表示地址，这是因为该计算机使用64位地址。在采用32位地址的计算机上，64位地址将
被32位地址代替，所以整数程序中的几乎所有双字访问都变为单字访问
在一些体系结构中，寄存器中的对象可以作为字节或半字进行访问。但是，这种访问是非
常罕见的——在VAX上，不超过12%的寄存器引用采用这种方式，也就是这些程序中所有操作
数访问的大约6%。

\section{指令集中的操作}
大多数指令集体系结构支持的操作符可以如表A-5那样进行分类。关于所有体系结构的一
条经验规律是：执行最多的指令是一个指令集中的简单操作。例如，表A-6给出了10种简单指
令，对于一组在流行 80x86上运行的整数程序，这10种简单措令占所执行指令的96%。因为它
们很常见，所以这些指令的实现应当确保它们能够快速完成。

\begin{verbatim}
    表A-5 指令操作符的分类与示例。所有计算机通常都提供所有前三类运算
    操怍符类型
    算术与逻辑
    轮数算术与逻辑运算：加、减、与、或、乘、除
    数据传送
    载人-存储（在采用存储器寻址的计算机上为move指令）
    控制
    分支、跳转、过程调用与返回、陷阱
    系统
    操作系统调用、虚拟存储器管理指令
    淨点
    浮点运算：加、乘、除、比较
    十进制
    十进制加、十进制乘、二进制到字符的转换
    字符串
    字符串秘动、宇符串比较、字符申搜索
    图形
    像素与顶点操作、压缩/解压缩操作
\end{verbatim}

*在不同体系结构中，指令集中对系统功能的支持有所不同，但所有计算机都必须对一些基本的系统功能提供指令支
持。指令集对后4类的支持教量可能为0，也可能包含大量特殊指令。在任何计算机中都提供浮，点指令，供那些大量
使用浮，点数的应用程序使用。这些指令有时是可选指令集的一部分。十进制和字符串指令有时是基元类型，比如在
VAX或IBM360中，也可能是由編译器使用更简单的指令合成的。圈形指令通常会对许多較小的数据頂进行并行操
作—例如，对2个64位操作数执行8个8位加法。

前面曾经提到，表A-6中的指令在每一台计算机的每个应用程序（台式机、服务器和嵌人
式）中都可以找到，会对表A-5中的操作进行一些变化，而这主要取决于该指令集包含哪些数
据类型。
\begin{verbatim}
    排
    位
    2
    3
    4
    5
    6
    7
    8
    9
    10
    表A-6 80x86中执行最多的前10类指令
    80x86指令
    载人
    条件分支
    比较
    存储
    整数均值（占所执行指令总数的百分比）
    22%
    20%
    16%
    12%
    8%
    与
    滅
    寄存器之间的移动
    调用
    返回
    6%
    ：
    $%
    4%
    1%
    1%
    96%
    总计
\end{verbatim}
•简单指令是这个列表的主体，占所执行指令的 96%。这些百分数是5个 SPECint92 程序的均值。

\section{控制流指令}
由于分支与跳转行为的测量在相当程度上与其他测量值和程序无关，所以我们现在研究控
制流指令的使用，它与上一节的操作之同没有什么共同点。

关于改变控制流的指令，没有非常一致的术语。在20世纪50年代，它们通常被称为转移
（transfer）。在20世纪60年代，开始使用分支（branch）一词。后来计算机还另外引入了一些
名称。在本书中，当控制中的改变是无条件时，我们使用跳转（jump），当改变是有条件时，
使用分支。

我们可以区分4种不同类型的控制流变化：
\begin{itemize}
    \item 条件分支；
    \item 跳转；
    \item 过程调用；
    \item 过程返回。
\end{itemize}
由于每个事件都是不同的，可能使用不同指令，可能拥有不同行为，所以我们希望知道这
些事件的相对频率。图A-8 中给出了这些控制流指令在一个载人-存储计算机上的出现频率，我
们就是在这种计算机上运行基准测试的。

图A-8 将控制流指令分为三类：调用或返回、跳转和条件分支。条件分支显然占绝大多数。每种类型的
计数分别用三个长条来显示。用于收集这些统计数字的程序和计算机与图 A-3中的数字相同

\subsection{控制流指令的寻址方式}

控制流指令中的目标地址在任何情况下都必须指定。在绝大多数情况下，这个目标是在指
令中明确指定的，但过程返回是一个重要例外，这是因为在编译时无法知道要返回的目标位置。
指定目标的最常见方法是提供一个将被加到程序计数器（PC）的位移量。这类控制流指令被称
为PC相对指令。由于目标位置通常与当前指令的距离较近，而且，在指定相对于当前PC的位
置时，需要的位数较少，所以 PC相对分支或跳转具备一些优势。采用PC相对寻址还可以使代
码的运行不受装载位置的影响。这一特性称为位置无关，可以在链接程序时减少一些工作，而
且对于在执行期间进行动态链接的程序也比较有用。

如果在编译时不知道目标位置，为了实现返回和间接跳转，需要一种不同于 PC 相对寻址
的方法。这时，必须有一种动态指定目标的方法，使目标能够在运行时发生变化。这种动态寻
址可能非常简单，只需要给出包含目标地址的寄存器名称即可；跳转可能允许使用任意寻址方
式来提供目标地址。

这些寄存器间接跳转对于其他4种重要功能也是有用的。

\begin{itemize}
    \item case 或 switch 语句，大多数编程语言中都会有这些语句（用于选择几种候选项之一）。
    \item 虛拟函数或虚拟方法，存在于诸如C++或Java 之类的面向对象式语言中（允许根据参数
    类型调用不同例程）。
    \item 离阶函数或函数指针，存在于诸如C或C++等语言中（它允许以参数方式传递一些函数，
    提供面向对象编程的一种好处）。
    \item 动态共享库（允许仅当程序实际调用一个库时才在运行时加载和链接，而不是在运行程
    序之前进行静态加载和链接）。
\end{itemize}

在所有这4种情况下，目标地址在编译时都是未知的，因此，通常是在寄存器间接跳转之前从
存储器加载到寄存器中。
由于分支通常使用 PC 相对寻址来指定其目标，一个重要的问题就是关注分支目标距离分
支有多远。了解这些位移量的分布有助于选择支持哪些分支偏移量，从而会影响到指令长度和
编码。图A-9给出了指令中PC相对分支的位移量分布。这些分支中大约有75%是正向的。

分支距离（以目标与分支指令之间的指令数来表示）。整数程序中的最常见分支是转向可以用4~8
位编码的目标地址。这一结果告诉我们，短位移量字段对于分支指令通常足够了，有了较小分支
位移量的较短指令，设计者可以提高编码密度。这些测量结果是在载入-存储计算机（Alpha 体系
结构）上测得的，所有指令都与字边界对齐。对于同一程序，如果体系结构需要的措令较少（比
如VAX），那分支距离就较短。但是，如果计算机的指令长度是变化的，可以与任意字节连接对齐，
则表示该位移量所需要的位数可能会增加。收集这些统计数字的程序和计算机与图A-4中相同

\subsection{条件分支选项}
由于大多数控制流改变都是分支，所以决定如何指定分支条件是很重要的。表A-7列出了
当前使用的了种主要技术及其优缺点。

分支的最明显特性之一是大量比较都是简单的测试，其中有很多是与0进行比较。因此，
一些体系结构选择将这些比较当作特殊情景进行处理，特别是在使用比较并分支指令中。图
A-10给出了条件分支中用到的各种不同比较的频率。

\begin{verbatim}
    A.6 控制流指令
    379
    表A-7 对分支条件进行求值的主要方法及其优缺点
    名
    称
    示
    例
    如何测试条件
    优
    点
    条件代码（CC）80x86、ARM、POWEPC、
    测试由ALU运算设 有时条件设置
    SPARC、SupetH
    定的特殊位，可能受
    比较自由
    程序的控制
    缺点
    CC是一种额外状态。由于条
    件代码是将来自一条指令的
    信息传送给一个分支，所以
    它们限制了指令的顺序
    占用一个寄存器
    灸件寄存罪
    Alpba、Ms
    用比较结果测试任 简单
    意寄存器
    比较与分支
    PA-RISC、VAX
    比较是分支的一部 分支需要一条指 对于流水线执行来说，每个
    分。比较范围通常仅 令，而不是两条 指令要完成的工作可能过多
    限于子集
\end{verbatim}
*尽管泰件代码可以由 ALUJ运算谈定（用于其他目的），但对程序的测量显示，这种情现会很少发生。当条件代码由
一大組指令或一組偶然选定的指令设定，而不是由指令中的一个比特来谈定时，就会出现条件代码的童妻实現问题。
拥有比较和分支指令的计算机通常会限制比较范围，使用寨件寄存器进行更复杂的比较。通常，对于根据浮点比較
进行的分支和基于整数比較进行的分支会采用不同技术。由于根据浮，点比較执行的分支教目要远小于根据整數比較
进行的分支数目，所以这种做法是合理的。

图A-10 条件分支中不同比较类型的使用频率。编译器与体系结构的这种组合中，小于（或等于）分支
占主导地位。这些测量值包含了分支中的整数和浮点比较。用于收集这些统计数字的程度和计
算机与图 A4中相同

\subsection{过程调用选项}
过程调用和返回包括控制转移，还可能涉及一些状态保存过程；至少必须将返回地址保存
在某个地方，有时保存在特殊的链接寄存器中，有时只是保存在GPR 中。一些较早的体系结构
提供了一种用于保存许多寄存器的机制，而较新的体系结构需要编译器为所存储和恢复的每个
寄存器生成存储和载入操作。

在保存寄存器时，有两种基本约定：要么保存在调用位置，要么保存在被调用的过内部。
调用者保存是指发出调用的过程必须保存它希望在调用之后进行访问的寄存器，因此，被调用
的过程不需要为寄存器操心。被调用者保存与之相反：被调用过程必须保存它希望使用的寄存
器，而调用者不受限制。在某些时间必须使用调用者保存方法，其原因在于两种不同过程中对
全局可见变量的访问样式。例如，假定我们有一个过程 P1，它调用过程P2，这两个过程都对
全局变量x进行处理。如果 P1已经将 x分配给一个寄存器，它必须确保在调用P2之前将x保
存到P2知晓的一个位置。编译器希望知道被调用过程可能在什么时候访问寄存器分配量，由于
不同进程可能是分别编译的，所以增加了获知这一信息的难度。假定P2可能不会触及x，但可
能调用另一个可能访问x的进程P3，而P2和 P3是分别编译的。由于这些复杂性的存在，大多
数编译器会采用比较稳健的方式，由调用者将所有可能在调用期间访问的变量都保存起来。

在可以采用任一约定的情况下，有些程序更适于采用被调用者保存，有些程序更适于采用
调用者保存。结果，今天的大多数实际系统都采用这两种机制的组合方式。这一约定在应用程
序二进制接口（ABI）中指定，它确定了一些基本规则，指出哪些寄存器应当由调用者保存，
哪些应当由被调用者保存。在本附录的后面，我们将研究用于自动保存寄存器的高级指令与编
译需求之间的不一致之处。

\subsection{小结：控制流指令}
控制流指令属于执行频率最高的一部分指令。尽管条件分支有许多选项，但我们希望新体
系结构中的分支寻址能够跳转到分支指令之前或之后数百条指令处。这一要求意味着PC 相对
分支位移量至少为8位。我们还希望看到跳转指令采用寄存器间接和PC 相对寻址，来支持过
程返回和当前系统的许多其他功能。

我们现在已经从汇编语言程序员或编译器编写人员的层次，完成了对指令体系结构的浏览。
我们介绍了一种采用位移量、立即数和寄存器间接寻址方式的载人-存储体系结构。所介绍的数
据为8位、16位、32位和64位警数，还有32位和64位浮点数。指令包括简单操作、PC相对
条件分支、用于过调用的跳转和链接指令，还有用于过程返回的寄存器间接跳转（还有其他
一些应用）。

现在我们需要选择如何采用一种便于硬件执行的方式来表示这一体系结构。

\section{指令集编码}
显然，上述选择会影响到如何对这些指令进行编码，表示为供计算机执行的二进制形式。
这种表示形式不仅影响到程序经过编译后的大小，还会影响到处理器的实现，处理器必须对这
种表示形式进行译码，快速找出操作和操作数。操作通常在一个称为操作码的字段中指定。后
面将会看到，一个重要决定是如何通过编码将寻址方式与操作结合在一起。

这一决定取决于寻址方式的范围和操作码与寻址方式之间的独立程序。一些较早的计算机
有1~5个操作数，每个操作数有10种寻址方式（见表A-4）。对于如此大量的组合情况，通常
需要为每个操作数使用独立地址标识符：地址标识符告诉使用哪种寻址方式来访问该操作数。
另一个极端是仅有一个存储器操作数、仅有一或两种寻址方式的载人-存储计算机；显然，在这
种情况下，可以将寻址方式作为操作码的一部分进行编码。

在对指令进行编码时，由于寄存器字段和寻址方式字段可能在一条指令中出现许多饮，所
以寄存器数目和寻址方式的数目都对指令大小有显著影响。事实上，对于大多数指令，对寻址
方式字段和寄存器字体进行编码时所占用的位数，要远多于指定操作码所占用的位数。在对指
令集进行编码时，架构师必须平衡以下几种竞争力量。

\begin{enumerate}
    \item 希望允许尽可能多的寄存器和寻址方式。
    \item 寄存器字段和寻址方式字段的大小对平均指令大小存在影响，从而对平均程序大小产生
    影响。
    \item 希望编码后的指令长度易于以流水线实施方式处理。（易解码指令的价值在附录C和第
    3 章讨论。）至少，架构师希望指令长度为字节的总数，而不是任意位长度。许多台式机和服务
    器架构师已经选择使用固定长度的指令来获得实现方面的好处，不过这样是以牺牲平均代码规
    模为代价的。
\end{enumerate}

图A-11 给出三种常见的指令集编码选择。第一种称为变长编码，这是因为它几乎允许对所
有操作使用所有寻址方式。当存在许多寻址方式和操作时，这是最佳选择。第二种选择称为定
长编码，因为它将操作和寻址方式合并到操作码中。通常，采用定长编码时，所有指令的大小
都相同；当寻址方式与操作数较少时，其效果最好。变长编码与定长编码之间进行的权衡是程
序大小与处理器译码的难易程度。变长编码在表示程序时尽力减少所用位数，各条指令的大小
和要执行的工作量可能会有很大变化。
\begin{verbatim}
    操作与操
    地址标
    作数数目
    地标字段1
    地址标识符x
    地址字段n
    识符1
    （a）变长编码（例如，Intel 80x86、VAX）
    A221
    操作
    地址字段1
    地址宇段2
    地址字段3
    （b）定长编码（例如，AIpha、ARM.MIPS、PowePC.SPARC、Superl）
    操作
    地址标识符
    地址字段
    操作
    地址标识符1
    地址标识符2
    地址字段
    搡作
    地址标识符
    地址字段1
    地址字段2
\end{verbatim}
（c） 混合编码（例如，IBM 360/370、MIIPS16、Thumb、TI TMS320C54x）
图A-11

指令编码的三种基本变体：变长编码、定长编码、混合编码。变长格式可以支持任何数目的操
作数，每个地址标识符确定操作数的寻址方式和标识符的长度。这种方式的代码表示长度通常
是最短的，因为不会包含没有使用的字段。定长格式中的操作数个数总是相同的，寻址方式（如
果存在选项的话）作为操作码的一部分进行措定。它生成的代码规模通常是最大的。尽管字段
的位置不会变化，但不同指令会将其用于不同目的。混合编码方法拥有多种由操作码指定的格
式，添加了一到两个字段来指定寻址方式，还有一到两个字段来指定操作数地址

让我们看一条 80x86指令，作为变长编码的一个例子。

add EAX.1000（EBX）

add 是指一条有两个操作数的32位整数加法指令，这个操作码占1个字节。80x86地址标识符
为1或2个字节，指定源/目标寄存器（EAX）和第二个操作数的寻址方式（在这个例子中为位移
量）与基址寄存器（EBX）。这一组合占用1个字节来指定操作数。在32 位模式中（参见附录 K），
地址字段的大小为1或4个字节。由于1000大于2°，所以这条指令的长度是

1+1+4=6个字节

80x86指令的长度介于1~17个字节之间。80x86程序通常短于 RISC体系结构，后者使用定长格
式（参见附录K）。

有了变长编码和定长编码这两种指令集设计的极端情况之后，立即就可以想到第三种选择：
降低变长体系结构中指令大小与任务的变化程度，但提供多种指令长度，以缩小代码尺寸。这
种混合式方法是第三种编码选择，稍后将会看到其示例。

\subsection{RISC中的精简代码}
嵌人式应用程序中的成本和缩短代码非常重要，随着 RISC计算机开始进入这一领域，32
位定长格式已经成为一种负担。为应对这一情况，几家制造商提供了其 RISC指令集的一种新
混合版本，同时拥有16位和32位指令。这些较窄的指令支持较少的运算、较小的地址与立即
数字段、较少的寄存器和两地址格式，而不是 RISC计算机的典型三地址格式。附录K给出两
个示例——ARM Thumb 和 MIPS MIPS 16，这两个都声称代码规模最多可以缩减40%。

与这些指令集扩展相对，IBM 只是对其标准指令集进行了压缩，然后添加一些硬件，在因
为发生指令缓存缺失而从存储器中提取指令时，对其进行解压缩。因此，指令缓存中包含完整
的32位指令，但在主存储器、ROM和磁盘中保存的是压缩后的代码。MIPS 16和 Thumb 的优
点是指令缓存的工作方式使其好像增大了大约25%。而IBM 的 CodePack 意味着不需要为了处
理不同指令集而对编译器进行修改，指令译码仍然非常简单。

CodePack 首先对任意 PowerPC程序进行游程编码压缩，然后将所得到的压缩表载人芯片上
一个大小为 2KB的表中。因此，每个程序都有其自己独特的编码。为了处理分支（不再与宇边
界对齐），PowerPC 在存储器中生成一个散列表，将压缩前后的地址对应起来。它像 TLB一样
（见第2章），缓存了最近使用过的地址映射，用来减少存储器访问的次数。IBM 宣称整体性能
成本为10%，代码规模缩减 35%~40%。

而日立则为嵌人式应用程序发明了一种采用固定16位格式的 RISC指令集，称为 SuperHi
（见附录K）。它有16个而不是32个寄存器，使其与较窄的格式和较少措令相吻合，而其他方
面看起来与经典 RISC体系结构一致。

\subsection{小结：指令集编码}
前几节讨论了指令集设计时所作的决策，这些决策决定了架构师是否能够在变长指令编码
和定长指令编码之间进行选择。给定选择之后，那些看重代码规模多于性能的架构师会选择变
长编码，而看重性能多于看重代码规模的架构师则会选择定长编码。附录E给出了架构师的13
个选择结果示例。在第3章和附录C中进一步讨论这种变化对处理器性能的影响。

我们几乎已经为将在 A.9节介绍的 MIIPS 指令集体系结构奠定了基础。但在开始介绍之前，
先来简要地了解一下编译器技术及其对程序特性的影响，这也会有所帮助。

\section{交叉问题：编译器的角色}

今天，几乎所有的台式机和服务器应用程序都是用高级语言编写的。这种开发意味着：由
于所执行的大多数指令都是编译器的输出，所以指令集体系结构基本上就是编译器目标。在这
些应用程序的早期，在体系结构方面作出的决策经常是为了简化汇编语言编程，或者是针对特
定内核。由于编译器会显著影响到计算机的性能，所以理解今天的编译器技术对于设计、高效
实现指令集是至关重要的。

曾经有一种很流行的做法：试图将编译器技术及其对硬件性能的影响与体系结构及其性能
隔离开来，就像过去经常尝试将体系结构与其实现隔离开来一样。对于今天的台式机编译器和
计算机，这种隔离基本上是不可能的。体系结构方面的选择会影响到为一台计算机生成的代码
质量和为其构造优良编译器的复杂性，这种影响可能是正面的，也可能是负面的。

在这一节，我们主要从编译器的视角来讨论指令集的关键目标。首先回顾对当前编译器的
剖析。接下来讨论编译器技术如何影响架构师的决策，还有架构师如何增大或降低编译器生成
良好代码的难度。最后回顾编译器和多媒体处理，很遗憾，这是编译器编写人员与架构师之间
协作不佳的一个示例。

\subsection{目前编译器的结构}

首先让我们看看今天的最佳编译器是什么样的。图 A-12显示了目前编译器的结构。
\begin{verbatim}
    相关性
    与语言有关，
    与机器无关
    功能
    将语言转换为公井
    中间形式
    中间表示
    多少与语言相关，
    大体与机器无关
    例如，循环转换和过程
    内联化（也称为进程整合）
    与语言相关较低，与机
    器稍微有关（例如，寄
    存器数目/类型）
    包括全局和本地优化器
    ＋寄存器分配
    详尽的指令选择和机器相
    高度机器相关，语言无关
    关优化，可能包含汇编器，
    或后面跟有汇编器
    图A-12
\end{verbatim}
编译器通常包括2~4遍扫描（pass），一些优化程度更高的编译器会有更多遍扫描。当输入相
同时，以不同优化级别编译的程序应当给出相同结果，图上的结构将这种可能性增至最大。优
化扫描的设计是希望获得最优代码，如果希望加快编译速度，并且可以接受较低质量的代码，
那就可以眺过优化扫描。扫描就是编译器读取和转换整个程序的一个阶段（phase）。（阶段一词
经常与扫描互换使用。）由于优化扫描是独立的，所以有多种语言使用了相同的优化和代码生成
扫描。一种新的语言只需要一个新的前端即可

编译器编写人员的首要目标是正确性——所有有效程序的编译结果都必须正确。第二个目
标通常是编译后的代码速度。通常，还有一整套目标排在这两个目标之后，包括快速编译、支
持调试、语言之间的互操作性。正常情况下，编译器中的各次扫描将更抽象的高级表示转换为
逐渐降低层级的表示方式。最后到达指令集级别。这种结构可以帮助控制转换的复杂度，更容
易编写出没有错误的编译器。

正确编写编译器是一件很复杂的事情，而所能完成的优化程度主要受这一复杂度的限制。
尽管采用多遍扫描结构可以帮助降低编译器的复杂性，但它也意味誉编译器必须进行排序，某
些转换必须在其他转换之前完成。在图 A-12所示的优化编泽器框图中可以看出，某些高级优化
要在执行很久之后，才可能知道最终代码会是什么样子。一旦执行这种转换，编译器就不太可
能再返回并重新审视所有步骤，甚至撤消这些转换，这样的成本太过高昂。无论是编译时间还
是复杂性，都不允许进行这种迭代。因此，编译器假定最后的几个步骤有能力处理特殊的问题。
例如，在知道被调用过程的确切大小之前，编译器通常就必须选择对哪些进程调用进行内联展
开。编泽器编写人员将这一问题称为阶段排序问题。

这种转换排序如何与指令集体系结构互动呢？一种名为全局公共子表达式消去法的优化提
供了一个很好的例子。这种优化找出一个表达式计算相同取值的两个实例，并将第一次计算的
结果值保存在临时存储位置。然后利用这个临时值，清除这一公共表达式的第二次计算。

为使这一优化发挥显著效用，必须将临时值分配到寄存器中。否则，先将临时值存储在存
储器中，之后再重新载人它，其成本将会抵消因为不用重复计算该表达式所节省的成本。的确
存在一些情况：如果没有将临时值保存到寄存器中，这一优化会减缓代码的运行速度。寄存器
分配通常是全局优化扫描即将结束、马上要生成代码时进行的，所以阶段排序使上述问题变得
复杂。因此，执行这一优化的优化程序必须假定寄存器分配器会将这一临时值分配到寄存器中。
根据转移类型，可以将现代编译器执行的优化进行如下分类：

\begin{itemize}
    \item 高级优化一般对源代码执行，并将输出结果传送给之后的优化扫描；
    \item 本地优化仅对直行代码段（编译器设计者称为基本块）内的代码进行优化；
    \item 全局优化将本地优化扩展到分支范围之外，并引人了一组专为优化循环的转换；
    \item 寄存露分配将寄存器与操作数关联在一起；
    \item 与处理器相关的优化尝试充分利用特定的体系结构知识。
\end{itemize}

\subsection{寄存器分配}

鉴于寄存器分配在加快代码速度和使其他优化发挥效用方面扮演的角色，可以说它是最重
要的优化之一（甚至就是最重要的那一个）。今天的寄存器分配算法以一种称为图形着色的技术
为基础。这种图形着色技术背后的基本思想是构造一幅图，用来表示可能执行的寄存器分配方
案，然后利用这个图来分配寄存器。大致来说，问题在于如何使用有限种颜色，使相关图中两
个相邻节点的颜色都不相同。这种方法的重点是将活跃变量全部分配到寄存器中。图形着色问
题的求解时间通常是图形大小的指数函数（NP完全问题）。不过，有一些启发式算法在实际中
的应用效果很好，生成分配结果的时间近似与图形大小成线性关系。

当至少有16个通用寄存器（多多益善）可用于为整数变量进行全局分配，而且有其他寄存
器分配为浮点变量时，图形着色方法的效果最好。遗憾的是，如果寄存器的数目很少，图形着
色的启发式算法很可能会失败，所以图形着色的效果不是太好。

\subsection{优化对性能的影响}

有时很难将一些较简单的优化（本地优化和与处理器相关的优化）与代码生成器中完成的
转换隔离开来。典型优化的示例在表A-8中给出。表A-8的最后一列指明对源程序执行所列优
化转换的频率。

\begin{verbatim}
    忧化名称
    高级
    过程整合
    本地
    公共子表达式消除法
    常量传播
    降低栈高度
    全局
    全局公共子表达式消去法
    副本传播
    米测量
    18%
    22%
    未测量
    代码移动
    消去归纳变量
    与处理 相关
    降低强度
    流水线调度
    分支偏移优化
    表A-8 主要优化类型及每种类型的示例。这些数据告诉我们各种优化技术的相对使用频率
    解释
    在源代码级别或接近该级别，与处理髒无关
    用过程主体代替过程调用
    在直行代码范園内
    用单一副本代替同一计算的两个示例
    对于一个被赋值为常量的变量，用该常量代替其所有实例
    重新排列表达式树，以最大限度地减少表达式求值所需要的资源
    跨越分支
    与本地优化相同，但这一版本跨越了分支范围
    对于一个已经被賦值为 的变量A（即A X），用 代替蛮量A
    的所有实例
    如果在循环的每次选代中，其中一些代码总是计算相同值，
    则从该循环中移除该代码
    筒化/消去循环内的数组寻址计算
    侬赖于处理器知识
    许多示例，比如用加法和移位来代替与常量的乘法
    重新排列指令顺序，以提高流水线性能
    选择能够到达目标的最短分支位移
    优化转换总数的百分比
    13%
    11%
    16%
    2%
    未测量
    未测量
    未测量
\end{verbatim}
*第三列给出一些常见优化在一组12个小型Fortran 和Pascal 程序中的静态应用频率。在测量过程中，编译器关究成了
9个本地与全局优化。图中给出了这些优化中的6种，剩下3种的总静态频率占18%。“未测量”是指没有测量讓优化
方法的使用次数。与处理器相关的优化通常是在代码生成器中完成，所有这些优化都来在此次试验中测量。所示百
分比是特定类型的静杰优化所占的比例。数据来自 Chow［1983］（使用 Standford UCODE编译器收集）

图A-13显示了对两个程序的指令进行各种优化的效果。在这个例子中，与未经优化的程序
相比，已优化程序执行的指令数会减少大约25%~90%。该图表明在提议新指令集功能之前首先
浏览已优化代码的重要性，因为编译器可能会将架构师正在尝试改进的指令完全清除。
\begin{verbatim}
    lucas, leve! 3
    11%
    •分支/调用
    浮点ALU运算
    lucas, level 2
    12%
    圝载入-存储
    Iucas, level 1
    21%
    豳整数ALU运算
    100%
    器
    编译
    76%
    76%
    mcf, level 3
    mcf,level2
    mcf, level I
    mcf, level 0
    84%
    图 A-13
    100%
    0%
    20%
    40%
    60%
    80%
    100%
    所执行的未优化指令所占百分比
\end{verbatim}
当编译器优化级别变化时，SPEC2000 中 |ucas 和 mcf 程序中指令数目的变化。第0级表示未优
化代码。第1级包含本地优化、代码调度和本地寄存器分配。第2级包括全局优化、循环转换（软
件流水线）和全局寄存器分配。第3级增加了过程整合。这些试验是在Alpha编译器上执行的

\subsection{编译器技术对架构师决策的影响}
编译器与高级语言之间的互动显著影响着程序利用指令集体系结构的方式。这里有两个重
要问题：如何对变量进行分配和寻址？需要多少个寄存器才能对变量进行适当分配？为了回答
这些问题，必须看看当前高级语言用来保存数据的三个独立区域。

\begin{itemize}
    \item 栈用于分配本地变量。栈会在进程调用与返回时相应增大或缩小。栈内的对象是相对于
    栈指针进行行寻址的，这些对象主要是标量（单变量），而不是数组。栈用于活动记录，
    而不是用于表达式求值。因此，几乎从来不会在栈中压人或弹出数值。
    \item 全局数据区用于静态分配所声明的对象，比如全局变量和常量。这些对象中有很大一部
    分都是数组或者其他聚合数据结构。
    \item 堆用于分配那些不符合栈规则的动态对象。堆中的对象用指针访问，通常不是标量。
\end{itemize}

对于分配到栈中的对象，寄存器分配的处理效率要远高于对全局变量的处理效率，而寄存
器分配对于分配到堆中的对象基本上不可能实现，因为它们是用指针访问的。全局变量和一
栈变量也不可能分配，因为它们具有别名，也就是说有多种方法可以引用变量的地址，从而不
能合法地将其放到寄存器中。（在当今的编译器技术中，大多数堆变量实际上都拥有别名。）

例如，考虑以下代码序列，其中\&返回变量的地址，\*取得指针所指向的对象：
\begin{verbatim}
    p = 8a-- 将a的地址放入p中
    2-•.-- 直接汐a值
    *p=•.--使用p a賊值
    •••a•-访问a
\end{verbatim}

不可能跨过对 的赋值而对变量a进行寄存器分配，同时还不生成错误代码。在使用别名时，
通常很难甚至不可能判断指针可能措向哪些对象，所以会导致一个实质性问题。编译器必然为
保守的，如果有指针可能指向过程中的多个本地变量之一，某些编译器就不会在寄存器中分配
该过程的任意本地变量。

\subsection{架构师如何帮助编译器编写人员}

今天，编译器的复杂性并非来自对诸如 A=B+C 等简单语句的转换。大多数程序都具有局
部简单性，简单转换的效果很好。之所以会有这种复杂性，是因为程序规模庞大而且其全局互
动非常复杂，还因为编译器的结构决定了在判定哪种代码序列最佳时，一次只能判断一步。

编译器编写人员在工作时，通常会遵循他们自己对一条体系结构基础原理的推论：加快常
见情况的速度、保证少见情况的正确性。也就是说，如果我们知道哪些情况是常见的，哪些情
况是少见的，而且为这两种情况生成代码都是比较轻松的事情，那少见情况的代码质量可能就
不是非常重要——但必须正确！

一些指令集特性可以为编译器编写人员提供帮助。这些特性不应被看作需要严格执行的规
则，而应当看到一种指南，便于编写出生成高效、正确代码的编译器。
\begin{itemize}
    \item 提供正则性—只要可能，指令集的三个要素——操作、数据类型和寻址方式，就应当
    是正交的。如果体系结构的两个方面互不影响，就说它们是正交的。以操作和寻址方式为
    例，如果对于任何一个可以应用寻址方式的操作，都可以向其应用所有寻址方式，那就说
    操作和寻址是正交的。这种正则性有助于简化代码生成过程，如果在决定生成何种代码时，
    需要分散在编译器的两遍扫描中做出决策，那这一特性尤为重要。这一特性的一个典型反
    例是：限制可供特定指令类型使用的寄存器。针对专用寄存器体系结构的编译器通常会陷
    入这种两难境地。因为这一限制，编译器可能会发现有许多空闲寄存器，但却都不适用！
    \item 提供原型而非解决方案——与一种语言构造或内核功能“相匹配”的特殊功能通常是无法
    使用的。为支持高级语言所做的尝试可能仅对一种语言有效，也可能与该种语言的正确、
    高效实现相偏离，可能有点过头，也可能有所不及。A.10节给出一个例子，说明这些尝
    试是如何失败的。
    \item 简化候选项之间的权衡——对于编译器编写人员来说，最艰巨的任务之一就是对于所出
    现的任何一段代码，都能指出哪种指令序列最为适合。在早些日子里，指令数或总代码
    规模可能是好的度量标准，但我们在第1章已经看到，现在已经并非如此了。设计者所
    做的任何事情，只要能够帮助编译器编写人员了解替代代码序列的成本，就能帮助改进
    代码。在进行这种复杂权衡时，最困难的情景之一发生在寄存器-存储器体系结构中，就
    是判断一个变量的引用次数达到多大数值以后，将其载入寄存器的成本才会更低一些。
    这一阈值很难计算，事实上，在同一体系结构的不同模型之间也可能发生变化。
    \item 提供一些指令，将编译时的已知量绑定为常量—编译器编写人员特别讨厌处理器在运
    行时费力解读一个在编译时就已经知晓的取值。有些指令需要解读在编译时就已经固定
    的取值，这就是以上原则的绝佳反例之一。例如，VAX 进程调用指令（calls）会动态解
    释一个掩码，这个掩码说明在进行调用时要保存哪些寄存器，但它在编译时就已经固定
    下来了（见A.10节）。
\end{itemize}

\subsection{编译嚣对多媒体指令的支持（或支持不足）}
唉！SIMD指令（见4.3节）的设计者基本上会忽略上一小节的内容。这些指令往往就是解
决方案，而不是原型；它们缺少寄存器；数据类型与现有编程语言不匹配。架构师希望找出一
种能够帮助某些用户的廉价解决方案，但通常只有很少一些低级图形库例程使用它们。

SIMID 指令实际是一种出色体系结构的简化版本，它拥有自己的编译器技术。在4.2节进行
了解释，向量体系结构对数据的向量进行操作。多媒体内核最初是为科学代码发明的，通常也
是可以向量化的，当然通常是处理较短的向量。4.3节曾经提及，我们可以将 Intel 的 MIMXX 和
SSE 或者 PowerPC的 AltiVec 看作简单的短向量计算机：MIMX 的向量可以有8个8位元素、4
个16位元素或2个32位元素，AltiVec的向量长度是以上长度的两倍。它们被实现为宽寄存器
中的相邻窄元素。

这些微处理器体系结构将向量寄存器大小设定到体系结构内部：对于 MIMX，元素大小的
总和限制为64位，AltiVec 限制为 128位。当 Intel 决定扩展到128位向量时，它添加了一整套
新指令，名为流式SIMD扩展（SSE）。

向量计算机的一个主要优势是：一次载入许多元素，然后将执行与数据传输重登起来，从
而隐藏存储器访问的延迟。向量寻址方式的目标是收集散布在存储器中的数据，以紧凑方式放
置它们，便于对其进行高效处理，然后再将处理结果放回所属位置。

向量计算机包括步幅寻址和集中/分散寻址（见4.2节），以提高可向量化程序的数目。步幅
寻址在每次访问之间跳过数量固定的一些字，所以顺序寻址经常被称为单位步幅寻址。集中与
分散寻址在另一个向量寄存器中查找其地址：将其看作向量计算机的寄存器间接寻址。与之相
对，从向量的角度来看，这些短向量 SIMD 计算机仅支持单位步幅访问：存储器访问一次从单
个宽存储器位置载人或存储所有元素。由于多媒体应用程序的数据经常是一些流，起始点和终
止点都在存储器中，步幅寻址方式和集中/分散寻址方式是成功实现向量化的必备条件（见4.7
节）。

举例
下面的例子将一个向量计算机与 MINIX 进行对比，将像素的色彩表示方式由 RGB
（红、绿、蓝）转换为YUV（发光度色度），每个像素用3个字节表示。这种转换
只需要三行C代码，放在循环中即可：
Y =（9798*R + 19235*G + 3736*B）/ 32768；
U = （-4784*R - 9437*G
+ 4221*B）
/ 32768 + 128；
V =（20218*R - 16941*G - 3277*B）/ 32768 + 128；

宽度为64位的向量计算机可以同时计算8个像素。一个采用步幅寻址的媒体向量
计算机将执行以下操作：

口 3 次向量载人（以获得RGB）；
口3次向量相乘（转换R）；
口6次向量乘加（转换G和B）；
口 3 次向量移位（除以 32 768）；
口2次向量加（加上128）：
口3 次向量存储（存锗 YUV）。

总共有20条指令用于执行前面 C代码中转换8个像素的20个操作［Kozyrakis
2000］。（由于向量可能有32个64位元素，这一代码实际上可以转换最多32x
8=256个像索。）

与之相对，Intel 网站显示一个对8个像素执行相同计算的库例程使用了116条 MIMXX
指令和6个80x86 指令［nte!2001］。指令数之所以会增加到6倍是因为没有步幅存储
器访问，需要大量的指令来载人RGB 像素并解包，然后再打包并存储YUV像素。

采用受体系结构限制的短向量，而且没有多少寄存器和简单的存储器寻址方式，就很难利
用向量化编译器技术。因此，这些 SIMID 指令更可能出现于硬编码库中，而不是编译后的代码中。

\subsection{小结：编译器的角色}

这一节给出了几点建议。第一，我们希望一种新的指令集体系结构中至少拥有16个通用寄
存器（另外用于浮点数的寄存器不计在内），以简化使用图形着色的寄存器分配。关于正交性的
建议意味着所支持的全部寻址方式都适用于所有传送数据的指令。最后的三点建议（提供原型
而非解决方案、筒化候选项之间的权衡、不要在运行时绑定常量）都意味着注重简单性是最稳
妥的。换句话说，要想清楚，在指令集设计中，少就是多。SIMID扩展是一个出色营销的例子，
而不是软硬件协调设计的杰出成果。

\section{融会贯通：MIPS 体系结构}

在这一节，我们介绍一种名为 MIPS 的简单64位载入-存储体系结构。MIIPS 和RISC系列
的指令集体系结构的基础与前几节讨论的内容相似。（附录L.3节讨论了这些体系结构如何、为
何变得流行。）下面回顾一下我们在每一节对桌面应用程序的期望。

\begin{itemize}
    \item A.2 节—以载入-存储体系结构使用通用寄存器。
    \item A.3节—支持以下寻址方式：位移量（地址偏移大小为12~16位）、立即数（大小为8~16
    位）和寄存器间接寻址。
    \item A.4节——支持以下数据大小和类型：8位、16位、32位和 64位整数以及 64位 IEEE754
    浮点数。
    \item A.5 节——支持以下简单指令（它们占所执行指令的绝大多数）：载人、存储、加、减、
    移动寄存器和移位。
    \item A.6节—相等、不相等、小于、分支（长度至少为8位的PC相对地址）、趴转、调用
    和返回。
    \item A.7 节——如果关注性能则使用定长指令编码，如果关注代码规模则使用变长指令编码。
    \item A.8节—至少提供16个通用寄存器，确保所有寻址模式可应用于所有数据传送指令，
    •希望获得最小规模的指令集。这一节并没有包含浮点程序，但它们经常使用独立的浮点
    寄存器。其理由是增大寄存器的总数，但不会在指令格式或通用寄存器堆的速度方面产
    生问题。不过，这两个方面并非相互独立。
\end{itemize}

我们在介绍 MIIPS时，将展示它是如何遵循这些建议的。与最近的大多数计算机类似，MIPS
强调：

\begin{itemize}
    \item 筒单的载人-存储指令集；
    \item 针对流水线效率的设计（在附录C中讨论），包括定长指令集编码；
    \item 编译器目标的效率。
\end{itemize}

MIPS 提供了一种非常适合研究的体系结构模型，不仅是因为这种处理器非常普及，还因为它是
一种非常易于理解的体系结构。我们已经在第3章并将在附录C中再次使用这一体系结构，它
是大量练习和编程项目的基础。

从1985年诞生第一个MIPS处理器以来，已经发布了 MIPS 的许多版本（见附录K）。我们
将使用其中一个现在被称为MIPS64 的子集，它经常被简写为 MIPS，这一完整指令集可以在附
录K中找到。

\subsection{MIPS的寄存嚣}
MIPS64 有32个64位通用寄存器（GPR），即RO、R1••••R31。GPR 有时也称为整数寄存
器。此外，还有一组32位浮点寄存器（FPR），即FO、F1•••••F31，它可以保存32个单精度（32
位）值或32位双精度（64位）值。（在保存一个单精度数时，另一半 FPR没有使用。）它提供
了单精度和双精度浮点运算（32位和64位）。MIPS 还包括在单个 64位浮点寄存器中对两个单
精度操作数进行运算的指令。

RO的值总是0。我们稍后将会看到如何使用这个寄存器将简单指令集合成各种有用操作。
一些特寄存器可以与通用寄存器进行相互转换。其中一个例子就是浮点状态寄存器，用
于保存有关浮点运算结果的信息。还有一些指令用于在 FPR和GPR之间移动数据。

\subsection{MIPS的数据类型}

MIIPS 的数据类型包括8位字节、16位半字、32位字和64位双字整型数据和32位单精度
与64位双精度浮点数据。添加半字是因为它们在诸如C之类的语言中存在这一类型，而且在一
些关注数据结构大小的程序（比如操作系统）中非常普遍。如果 Unicode 的应用变得更为广泛，
它们也会变得更流行。出于类似原因添加了单精度浮点操作数。（别忘了前面给出的警告：在设
计一种指令集之前应当测量大量程序。）

MIPS64 操作对64位整数和32位或64位浮点数进行操作。字节、半字和字被载入通用寄
存器中，并通过重复0或符号位来填充 GPR的64个位。一旦载人之后，就可以用64位整数运
算对其进行操作。

\subsection{MIPS的数据传输的寻址方式}

仅有的数据寻址方式就是立即数寻址和位移寻址，均采用16位字段。寄存间接寻址通过
在16位位務宇段中放置0来实现，而采用16位字段的寻址则是以寄存器，为基址寄存器来完
成的。尽管这种体系结构中仅支持两种寻址方式，但通过包含0提供了四种有效方式。

MIPS存储器可以用64位地址进行字节寻址。它有一个方式位，允许软件选择大端或小端。
由于它是一个载人-存储体系结构，介于存储器与GPS或 FRP之间的所有引用都是通过载人或
存储完成的。通过支持上述数据类型，涉及 GPR的存储器访问可以是字节、半字、字或双字。
FPR 可以载人和存储单精度或双精度数。所有存储器访问都必须对齐。

\subsection{MIPS指令格式}
由于 MIIS只有两种寻址方式，所以能把它们编码到操作码中。为便于处理器实现流水线
和译码，所有指令的长度都是32位，其中有一个6位的主操作码。图A-14显示了指令布局。
这些格式非常简单，提供16位字段用于位移量寻址、立即数常量寻址或PC相对分支寻址。
\begin{verbatim}
    I型指令
    6
    5
    I6
    编码：字节、半字、字、双宇的载入和存储。
    所有立即数（ t Op立即数）
    条件分支指令（rs为寄存器，［s未使用）
    跳转寄存器，眺转和链接寄存器
    （rd=0、 目的地、立即数=0）
    R型指令
    6
    5
    5
    s
    6
    J型指令
    寄存器-寄存器ALU操作：rt -ts funct rt
    函数对数据路径操作进行编码：Add,Sub•••
    读/写特寄存器和移动
    6
    跳转陷阱和跳转与链接陷阱，从异常返回
\end{verbatim}
图A-14 MIPS的指令布局。所有指令均采用三种类型之一进行编码，在每种格式的相同位置有公共字段

附录K给出MIPS 的一个变体（称为 MIPS 16），它拥有16位和32位指令来提高嵌入式应
用程序的编码密度。本书中一直使用传统的32位格式。

\subsection{MIPS操作}
MIPS 支持前面推荐的简单操作及其他一些操作。共有四大类指令：载入与存储、ALU运
算、分支与跳转、浮点运算。

任意通用或浮点寄存器都可以载人或存储，只是载入 RO没有任何效果。表A-9给出载人
与存储指令的一些例子。单精度浮点数占据浮点寄存器的一半。单、双精度之间的转换必须显
式完成。浮点格式为 IEEE 754（参见附录J）。表A-12中列出了这一部分给出的全部 MIPS指令。
表A-9 MIPS中的载入和存储指令

\begin{verbatim}
    指令举例
    LD R1.30（R2）
    LD R1.1000（RO）
    LH R1.60（R2）
    LB R1.40（R3）
    LBU R1.40（R3）
    LH R1,40（R3）
    指令名称
    载人双字
    载人双字
    载入字
    载人字节
    载人无符号字节
    载人半字
    含
    L.S F0,50（R3）
    戴人单精度浮点数
    L.D FO.50（R2）
    载入双精度浮点数
    SD R3,500（R4）
    存储双精度字
    SW R3.500（R4）
    存储字
    S.$ F0.40（R3）
    存储单糈度浮点数
    S.D F0.40（R3）
    存储双精度浮点数
    SH R3.502（R2）
    存储半字
    SB R2,41（R3）
    存储字节
    Regs［R1.］-64 Mem［：30+Regs［R2］］
    Regs［R1］ 64 Mem［1000+0］
    Regs［RI］ --o （Mem［ 60+Regs［R2］］0）32 維# Mem［ 60+Regs［R2］］
    RegS［R1］+6 （MemL 40+Regs［R3］］0）86 ## Mem［40+Regs［R3］］
    Regs［R1］-64 056 ##Mem［ 40+Regs［R3］］
    Regs［R1］-64（Mem［40+Regs［R3］］o）98 ##Men［40+Regs［R3］］ f#
    Mem［41+Regs［R3］］
    Regs［F0］+64 Mem［50+Regs［R3］］##032
    Regs［F0］--64 Mem［50+Regs［R2］］
    Mem［500+Regs［R4］］-6 Regs［R3］
    Mem［ 500+Regs［R4］］-32 Regs ［R3］32..63
    Mem［40+Regs［R3］］-32 Regs［F0］o..31
    Mem［40+Regs［R3］］-64 Regs［FO］
    Mem［502+Regs［R2］］-16 Reg$［R3］8..63
    Mem［ 41+Regs［R3］］--8 Regs［R2］$6.63
\end{verbatim}
*均使用单一寻址方式，需要存储器值对齐。当然，載入和存储都可用于全部所示数据类型。

为理解这些图形，需要对最初在A.3.2节使用的C描述语言再进行一些扩展。

\begin{itemize}
    \item 只要所传送数据的长度不够明确，则向符号一附加一个下标。因此，一，表示传送一个n
    位量。我们使用x，y- 表示应当将z传送给x和y。
    \item 使用一个下标来表示选择字段中的某一位。在标记字段中的各个位时，最高有效位从。
    开始。下标可能是单个数位（例如，Regs［R4］。给出 R4的符号位），也可能是一个子范围
    （例如，Regs［R3］s6.6给出 R3的最低有效字节）。
    \item 变量 Mem用作一个表示主存储器的数组，它是按字节地址索引，可以传送任意数目的
    字节。
    \item 使用一个上标来表示复制字段（例如，04给出长度为48位的全零字段）。
    \item 使用符号\#将两个字段事联在一起，可能出现在数据传输的任一端。
\end{itemize}

例如，假定 R8和 R10次64位寄存器：
\begin{verbatim}
    Regs［R10］32.63 个 32 （Mer［Regs ［R8］］o｝20那# Mem ［Regs［R8］］
\end{verbatim}

上式的含义是对某一存储器位置的字节进行符号扩展（该存储器位置由寄存器 R8的内容寻址），
构成一个32位量，存储在寄存器R10的低位。（R10的高位不变。）

所有 ALU 指令都是寄存器-寄存器措令。表A-10给出了算术/逻辑指令的一些例子。这些
操作包括简单的算术和逻辑运算：加、减、AND、OR、XOR和移位。所有这些指令的立即数形式
都是用16位符号扩展立即数提供的。操作LUI（加载高位立即数）加载一个寄存器的第32~47
位，并将该寄存器的其他位设置为 0。LUI允许在两条指令中内置一个32位常数，也可以在一
个额外指令中使用任意常数32位地址进行数据传送。

\begin{verbatim}
    表A-10
    MIPS的算术/逻辑指令的示例，有、无立即数
    指令举例
    指令名称
    含义
    DADDU R1.R2,R3
    加上无符号数
    Regs［R1］--Regs［R2］+Regs［R3］
    DADDIU RI.R2.#3
    加上无符号立即数
    Regs［R1］-RegsCR2］+3
    LUI RI.#42
    载入高位立即数
    Regs［R1］103##42##026
    DSLL RI,R2，#5
    逻辑左移
    Regs［R1］-Regs［R2］<45
    SLT R1,R2.R3
    若小于则置位
    if （Regs［R2］<Regs［R3］）Regs［R1］-1 else Regs［R1］-0
\end{verbatim}
前面曾经提到，R.0用于合并常见操作。载人常数的操作，其实就是执行一个源操作数为
RO的加立即数指令，寄存器-寄存器移动就是源操作数之一为RO的加法。我们有时会使用助记
符LI（表示载人立即数，load immediate）来表示前者，用助记符 MOV表示后者。

\subsection{MIPS控制流指令}

MIPS提供比较指令，它比较两个寄存器，查看第一个寄存器是否小于第二个寄存器。如果
该条件为真，则这些指令在目标寄存器中放入1（表示真）：否则，放人数值0。因为这些操作
会对寄存器进行“置位”，所以它们被称为“相等置位”、“不相等置位”、“小于置位”，等等。
这些比较指令还有立即数形式。

控制是通过一组跳转指令和一组分支指令处理的。表A-11 给出了一些典型的分支与跳转指
定。通过两种指定目标地址的方法以及是否设定链接来区分四种跳转指令。两种跳转指令使用
一个进行两位移位的26位偏移量，然后替代程序计数器的低28位，以确定目标地址（程序计
数器是指该跳转指令后面指令的程序计数器）。另两种跳转指令指定了包含目标地址的寄存器。
共有两类跳转：单纯跳转和跳转并链接（用于过程调用）。后者将返回地址（下一条顺序指令的
地址）放在R31中。

表A-11 MIPS中的典型控制流指令。所有控制指令（跳转到寄存器中的地址除外）都是PC相对的
\begin{verbatim}
    指令举例
    指令名称
    含义
    J
    name
    JAL name
    跳转
    PC36..B-name
    跳转并链接
    Regs［R31］-PC+8; PC36..63--name；
    （（PC + 4）-227）≤ name < （（PC+4）+227）
    JALR R2
    跳转并链接寄存器
    Regs［R31］-PC+8; PC-Regs［R2］
    JR R3
    眺转寄存器
    PC-Regs［R3］
    BEQZ R4,name
    等于攀分支
    if （Regs［R4］==0） PC -name；
    （（PC+4）-227）≤ name < （（PC+4）+2"7）
    BNE
    ：R3,R4.name
    不等于零分支
    if （Regs［R3］！= Regs［R4］）PC-name：
    （（PC+4）-217）≤ name < （（PC+4）+217）
    MOVZ R1.R2,R3
    等于零时的条件移动
    if （Regs［R3］==0）.Regs［R1］-Regs［R2］
\end{verbatim}
*注意，分支距萬大于地址宇段建议的距离；由于 MIIPS 指令的长度都是32位，所以将字节分支地址棄以4，以获得
更长的距离。

所有分支都是有条件的。分支条件由指令指定，它可以测试寄存器源操作数是否为 0；寄
存器可以包含一个数据值或比较的结果。还有一些条件分支指令用于判断一个寄存器是否为负
数，以及两个寄存器是否相等。分支目标地址由一个16位有符号偏移量指定，该偏移量被左移
两位，然后加到指向下一顺序指令的程序计数器。还有一个分支用来关注浮点条件分支的浮点
状态寄存器，如下文所述。

附录C和第3章表明：条件分支是流水线执行的主要挑战；因此，许多体系结构增加了用
于将简单分支转换为条件算术指令的指令。MIPS 包含在等于零或不等于零时执行的条件移动。
目标寄存器的值或者保持不变，或者由源寄存器之一的副本替代，具体取决于其他源寄存器的
值是否为零。

\subsection{MIPS 浮点运算}

浮点运算操控浮点寄存器，并指出运算是以单精度还是双精度执行。操作 MOV.S 和 MOV.D
将一个单精度（MOV.S）或双精度（MOV.D）浮点寄存器复制到另一个同种类型的寄存器中。操作
MFCI、MTCI、DMFC1 和 DMTCI 在单精度或双精度寄存器与整数寄存器之间移动数据，而且还提供
了整数向浮点的转换，反之亦然。

浮点运算为加、减、乘、除；后缀D表示双精度，后缀S表示单精度（例如，ADD. D、ADD.S、
SUB.D、SUB.S、MUL.D、MUL.S、DIV.D、DIV.S）。浮点比较指令会对特浮点状态寄存器中的一个
位进行置位，有一对分支指令可以检测这个位，即：BC1T 和 BCIF，也就是浮点真分支和淨点假
分支。

为进一步提高图形例的性能，MIPS64 中提供了一些可以针对64位高低位执行2个32位
浮点操作的指令。这些成对单精度操作包括：ADD.PS、SUB.PS、MUL.PS 和 DIV.PS。（它们使用双
精度载入和存储指令进行载入和存储。）

MIPS64 认识到多媒体应用程序的重要性，还引入了整数与浮点乘加指令：MADD、MADD.S、
MADD.D 和MADD.PS。在这些合并操作中，寄存器的宽度都相同。表 A-12给出了一部分 MIPS64
操作的清单及其含义。

\begin{verbatim}
    表A-12 MIPS64的部分指令
    指令类型/操作码
    数据传送
    LB,LBU,SB
    LH,LHU.SH
    LN.LHU.SW
    LD,SD
    L.S.L.D.S.S.s.D
    MFCO.MTCO
    Mov.S,MOV.D
    MFC1.MTC1
    算术/遻辑
    DADD, DADDI,DAODU,DADDIU
    指令含义
    在寄存器和存储暑之间，或者在整数和FP或特寄存器之间移动数据：唯一的
    存储器寻址模式是16位位移量加上GPR的内容
    载人字节、载人无符号字节、存储字节（至/自虀数寄存器）
    栽人半字、教入无符号半字、存储半字（至/自整数寄存器）
    载人字、载入无符号字、存储字（至/自整数寄存器）
    载人双字、存储双字（至/自整数寄存器）
    载入SP浮点、载入DP浮点、存储SP浮点、存储DP浮点
    在GPR与特殊寄存器之间复制数据
    将一个SP或DP FP寄存器复制到另一个FP寄存器
    在FP寄存器与整数寄存器之间复制32位
    对GPR中的整数或逻辑数据进行操作；带符号算术运算溢出时进行陷阱捕获
    加，加立即数（所有立即数为16位）：有符号和无符号
\end{verbatim}
\begin{verbatim}
    （续）
    指令类型/操作码
    DSUB,DSUBU
    DMUL,DMULU, DOIV, DDIVU,MADD
    AND.ANDI
    OR.ORI. XOR.XORI
    LUI
    DSLL,DSRL,DSRA, DSLLV, DSRLV，
    DSRAV
    SLT,SL.T1.SLTU. SLTIU
    控制
    BEQZ. BNEZ
    BEQ.BNE
    BC1T,BC1F
    MOVN,MOVZ
    J.JR
    JAL,JALR
    TRAP
    ERET
    浮点
    ADD.D,ADD.S.ADD.PS
    SUB.D.SUB.S.SUB. PS
    MUL.D,MUL.S.MUL.PS
    MADD.D.MADD.S, MADD.PS
    DIv.D.DIv.s.DiV.Ps
    CVT.-•-
    指令含义
    减，有符号和无符号
    乘和除，有符号和无符号：乘-加；所有运算的操作数和结果都是64位数值
    与，和立即数相与
    或，和立即数求或，异或，和立即数求异或
    裁人高位立即数，将立即数载人到寄存器的32~47位，然后进行符号扩展
    移位：立即数形式（DS_）和变量形式（DS_V）：移位为左逻辑移位、右逻辑
    移位、右算术移位
    若小于操作数则置位、若小于立即数则置位、有符号和无符号
    控制分支和跳转，相对于PC寄存語或通过寄存器控制
    GPR等于/不等于0时转移、相对于PC+4偏移16位偏移量
    GPR相等/不相等时转移、相对于PC+4转移16位偏移量
    测试FP状态寄存器中的对比位，并转移，相对于PC+4转移16位偏移量
    如果第三个GPR为负数/零，则将第一个GPR复制到第二个GPR
    眺转至与PC+4偏移26位偏移量的位置（J）、跳转至寄存器中的目标位置（JR）
    眺转和链接：将PC+4保存在R31中，目标为相对于PC（JAL）或寄存器（JALR）
    转移到操作系统的一个向量地址
    从异常中返回用户代码，恢复用户模式
    对DP和SP格式执行FP操作
    DP、SP数相加，一对SP数相加
    DP、SP数相减，一对SP数相减
    DP.SP浮点数相乘，一对SP数相乘
    DP、SP浮点数相乘加，一对SP数相乘加
    DP.SP浮点数相除，一对SP数相除
    转换指令：CVT.Xy从类型x转換为类型y，其中×和y为L（64位整数），W（32位
    整数），D（DP）或S（SP）。两个操作数都是FRP
    DP和SP对比：“_”=LT，GT,LE,GE,EQ,NE，在FP状态寄存器中置位
    C.D.C.S
\end{verbatim}
*图A-14列出了这些指令的格式。
\subsection{MIPS 指令集的使用}
为使读者了解哪些指令使用得更为频繁，表A-13 中给出了5个 SPECint2000程序中各指令
及指令类别的使用频率，表A-14给出了对于S个 SPECfp2000程序的相同数据。
表A-13 5个SPECint2000程序的MIPS动态指令比例
\begin{verbatim}
    指
    令
    gap
    gcC
    gzip
    mcf
    载人
    存储
    加
    26.5%
    25.1%
    20.1%
    30.3%
    10.3%
    13.2%
    5.1%
    4.3%
    21.1%
    19.0%
    26.9%
    10.1%
    1.7%
    2.2%
    5.1%
    3.7%
    perlbmk
    28.7%
    16.2%
    16.7%
    2.$%
    乘
    1.4%
    0.1%
    整数均侐
    26%
    10%
    19%
    3%
    0%
    A.9
    融会贯通：MIPS体系结构
    395
    （续）
    指
    令
    比较
    载人立即数
    条件分支
    条件移动
    跳转
    调用
    返回
    移位
    与
    或
    异或
    其他逻辑
    载人浮点
    存储浮点
    加浮点
    减浮点
    乘浮点
    除浮点
    移动寄存器-寄存器浮点
    比较浮点
    条件移动浮点
    其他浮点
\end{verbatim}
*注意整数寄存器-寄存器務动指令包含在“或”指令中。空白项表示取值为0.0%。
SPECfp2000中5个程序的MIPS动态指令比例
\begin{verbatim}
    指
    令
    art
    18.1%
    30.1%
    比较
    载人立即数
    条件分支
    条件移动
    跳转
    调用
    返回
    7.4%
    11.5%
    0.3%
    9.4%
    1.3%
    A-39
    A-40
    A-41
    A-42
    396
    附录A 指令集基本原理
    指
    令
    Appll
    0.7%
    Art
    Swim
    移位
    与
    或
    0.8%
    异或
    其他逻辑
    载人浮点
    11.4%
    存储浮点
    4.2%
    加深点
    2.3%
    滅浮点
    2.9%
    乘浮点
    8.6%
    除浮点
    0.3%
    移动寄存器-寄存器浮点
    0.7%
    比较浮点
    条件移动浮点
    其他浮点
    1.1%
    3.2%
    12.0%
    4.5%
    4.$%
    4.1%
    0.6%
    0.9%
    0.9%
    0.6%
    Equake
    0.2%
    0.2%
    2.3%
    0.1%
    0.1%
    19.7%
    2.7%
    9.8%
    1.3%
    12.9%
    0.5%
    1.2%
    0.6%
    Lucas
    1.9%
    1.8%
    1.0%
    7.2%
    16.2%
    18.2%
    8.2%
    7.5%
    9.4%
    16.8%
    $.0%
    9.0%
    4.7%
    6.9%
    0.3%
    0.9%
    1.8%
    0.8%
    0.8%
    1.6%
    （续）
    浮点均值
    1%
    0%
    2%
    1%
    0%
    15%
    7%
    7%
    3%
    8%
    0%
    1%
    0%
    0%
    0%
\end{verbatim}
* 注意整数寄存器-寄存嚣移动指令包含在“或” 指令中。空白项表示取值为0.0%。
\section{谬论和易犯错误}
架构师经常会抱有一些常见但却错误的观点。我们将在本节研究其中几个。
\subsection{勗犯错误 设计专门支持高级语言结构的“高级” 指令集功能。}
架构师试图在指令集中整合高级语言功能，从而提供功能强大、极具灵活性的指令。但是，
这些指令所完成的工作通常会超出常见情景下的需求，或者不能与某些语言的需求完全匹配。
许多此类努力的目的是消除20世纪70年代所说的语义鸿沟。尽管其思路是对指令集进行一些
补充，使硬件能够实现语言级的功能，但这些补充可能会生成 Wulf、Levin 和 Harbison ［1981］
所说的语义冲突：

……计算机设计者赋予指令过多的语义内容之后，也许只能在非常有限的上下文
中使用这些指令［P43］。

更经常出现的情况是，这些指令的功能过于强大——对最常见情景来说，它们太具一般性，
做了一些无用功，减缓了指令的执行速度。VAX CALLS 又是一个好例子。CALLS采用了“被调用
者保存策略”（要保存的寄存器由被调用者指定），但是，保存过程是由调用方的调用指令完成
的。CALLS 指令首先将参数压入栈，然后执行以下步骤。

\begin{enumerate}
    \item 必要时对齐栈。
    \item 将参数数目压人栈。
    \item 将过程调用屏蔽码指定的寄存器保存到栈中（见A.8节）。这个屏蔽码保存在被调用过
    程的代码中，这样，即使采用分离编译，也能允许被调用者指定要由调用者保存的寄存器。
    \item 将返回地址压人栈，然后压人栈底、栈顶措针（对于活动记录）。
    \item 清除条件代码，这样会将陷阱使能设置为已知状态。
    \item 在栈中压人表示状态信息的字和零字。
    \item 更新两处栈指针。
    \item 分支转移到过程的第一条指令。
\end{enumerate}
实际程序中的大量调用并不需要这么多开销。大多数过程知道它们的参数个数，可以建立
一条更快速的链接协定，使用寄存器而不是存储器栈来传递参数。此外，CALLS 指令强制为链接
使用两个寄存器，而许多语言只需要一个链接寄存器。很多希望支持过程调用和活动栈管理的
努力都失败了，要么是因为不满足语言要求，要么是通用性太强，使用成本过于高昂。

VAX设计者提供了一种更简单的指令JSB，由于它仅在栈中压人返回PC就眺至进程，所以
执行速度要快得多。但是，大多数 VAX编译器使用成本更高的CALLS指令。这些调用指令包含
在体系结构中，用于实现过程链接约定的标准化。其他计算机通过在编译器编写人员之间达成
一致而实现其调用约定的标准化，不再需要非常通用的复杂过程调用指令的开销。

\subsection{谬论 存在典型程序这样一种东西。}
许多人愿意相信存在一种用于设计最优指令集的单一 “典型”程序。例如，参见第1章讨
论的合成基准测试。本附录中的数据清楚地表明：各个程序对指令集的使用方式存在显著不同。
例如，图A-15 给出了4个 SPEC2000程序中数据传送大小所占的比例：很难说这4个程序中哪
个才是典型的。对于专门支持某一类应用的指令集，这种变化可能更大，比如其他应用就不会
使用十进制指令。

图A-15 4种SPEC2000 程序的数据引用大小。尽管可以计算平均大小，但很难声称这个平均值就是程
序的典型值
\subsection{易犯错误 不考虑编译器，仅通过指令集体系结构的创新来缩小代码规模。}
表A-15显示了 MIPS 指令集四种编译器的相对代码规模。架构师一直在为了将代码规模缩
小30%~40%而努力，而不同编译器策略对代码规模的影响则要大得多。和性能优化技术相似，
架构师应当首先考虑编译器所能生成的最紧凑代码，然后再考虑通过硬件创新来节省空间。

表A-15 EEMBC基准測试Telecom应用程序相对于Apogee Sottware Version 4.1C的代码规模
\begin{verbatim}
    编译髁
    Apogee Software
    Green Hills Mul2000
    Algorithmics
    Version 4.1
    Version 2.0
    SDE4.0B
    体系结构
    MIPSIV
    MIIPS IV
    MIPS 32
    处理器
    NEC VR5432
    NEC VR5000
    IDT32334
    自动相关内核
    01
    2.1
    1.1
    卷积编码器内核
    1.0
    1.9
    1.2
    定点位分配内核
    0I
    2.0
    1.2
    定点复数FFT内核
    1.0
    1.1
    2.7
    维特比GSM解码器内核
    1.0
    1.7
    0.8
    5种内核的几何平均
    1.0
    1.7
    1.4
    IDTIc 7.2.1
    MIPS 32
    IT 79RC32364
    2.7
    2.4
    23
    1.8
    rr
    20
\end{verbatim}
*这些指令集体系结构几乎相同，而代码规模部相差一倍。这些结果于2000年2月~6月报告。
\subsection{谬论 有缺陷的体系结构不可能获得成功。}
80x86 提供了一个很生动的例子：可能只有其创造者才喜爱这一指令集体系结构（见附录
K）。后来的Intel 工程师已经尝试纠正在设计80x86时作出的一些不受欢迎的体系结构决策。例
如，80x86 支持段式存储，而所有其他体系结构都选择了页式存储；它为整型数据使用扩展累
加器，而其他处理器则使用通用寄存器；它浮点数使用栈，而其他所有人在很久之前就放弃
了执行栈。

尽管存在这些重大问题，80x86体系结构仍然取得了巨大成功。其原因有三个方面：第一，
最初的IBM PC选择它作为微处理器，使80x86 的二进制兼容性变得极为重要。第二，摩尔定
律提供了足够的资源，供80x86微处理器先转换为内部 RISC指令集，然后再执行类似于 RISC
的指令。这种混合方式既能保证与宝贵的PC软件基础保持二进制兼容，又能实现与 RISC处理
器相当的性能。第三，PC微处理器的销售量如此之高，使Intel 可以很轻松地支付不断增加的
硬件转换设计成本。此外，高销售量使制造商能够抬高学习曲线，降低生产成本。

为进行转换而增大晶粒大小、提高功率，对于嵌人式应用程序来说可能会成为一种负担，
而对于桌面应用来说则极具经济意义。而且，它在桌面应用方面的成本性能也吸引了服务器领
域的关注，对服务器而言，它的主要弱点是采用了32位地址，AMD64 中用64位地址克服了这
一觖点（见第2章）。

\subsection{谬论 可以设计一种没有缺陷的体系结构。}
所有体系结构设计都需要在一组软硬件技术之间进行折中。随着时间的流逝，这些技术可
能会发生变化，原来曾经正确的决定可能看起来像是一些错误决定。例如，1975年，VAX设计
人员强调代码规模效率的重要性，低估了译码与流水化的简易程度在5年之后的重要性。RISC
阵营的一个例子是延迟分支（参见附录 K）。对于五级流水线来说，控制流水线冒险是很简单的
事情，但如果处理器的流水线更长，在每个时钟周期发射多条指令，那就是一个挑战了。此外，
几乎所有体系结构最终都会屈从于缺少足够地址空间这一问题。

总体来说，避免体系结构出现这些长期问题可能意味着会影响到它的短期效率，这是非常
危险的，因为一种新的指令集体系结构必须挣扎着经历最初几年的考验。

\section{结语}
最早体系结构的指令集受到当时硬件技术的限制。只要硬件技术允许，计算机架构师就会
探索支持高级语言的方式。因为这一探索，在三个不同时期内，人们关于如何高效支持程序有
着截然不同的考虑。20世纪60年代，栈体系结构变得非常流行。人们认为它们与高级语言非
常匹配，根据当时的编译器技术，可能也确实如此。20世纪70年代，架构师主要关注如何降
低软件成本。其解决方案主要是用硬件代替软件，或者提供能够简化软件设计人员任务的高级
体系结构。其结果就是高级语言计算机体系结构和诸如VAX之类的强大体系结构，这种体系结
构有大量的寻址方式、多种数据类型和高度正交的体系结构。20世纪80年代，一些更高级的
编译器技术和对处理器性能的再度重视见证了简单体系结构的回归，其主要基础就是载人-存储
型计算机。

20世纪90年代，指令集体系结构发生了以下变化。

\begin{itemize}
    \item 地址大小加倍—大多数台式与服务器处理器的32位地址指令集被扩展到64位地址，
    寄存器的宽度（及其他相关项目）被扩展到64位。附录K给出三个已经从32位扩展到
    64位的体系结构实例。
    \item 通过条件执行优化条件分支——在第3章，我们看到条件分支可能限制积极计算机设计
    的性能。因此，人们愿意将条件分支代替操作的条件执行，比如条件移动（见附录H），
    大多数指令集中都添加了这一指令。
    \item 通过预取优化缓存性能—第2章曾经解释过，由于一些计算机中发生缓存缺失时所消
    耗的指令时间可能与页面错误在早期计算机上消耗的时间一样多，所以存储器层次结构
    在计算机性能中扮演着更为重要的角色。因此添加了预取指令，以尝试通过预取来隐藏
    缓存缺失成本（见第2章）。
    \item 支持多媒体——大多数台式和嵌人式指令集都进行了扩展，为多媒体应用程序提供支持。
    \item 浮点运算速度更快—附录J描述了为提高浮点性能所添加的操作，比如执行乘加和成
    对单次执行的操作。（我们在 MIPS 中包含了此类操作。）
\end{itemize}

在1970年至1985年期间，许多人认为计算机架构师的主要任务是设计指令集。结果，当
时的教科书都在强调指令集设计，就像20世纪50年代、60年代的计算机体系结构教科书强调
计算机算术运算一样。人们希望经过专业训练的架构师能够深刻地了解流行计算机的优势与缺
点，特别是对后者的了解。在指令集设计的改进过程中，许多研究人员和教科书编写人员都没
有认识到二进制兼容性的重要性，给人们留下一种印象：许多架构师都有机会设计一种指令集。

今天的计算机体系结构定义已经进行了扩展，包含整个计算机系统的设计与评估，而不只
是指令集的定义，也不只是处理器的定义，因此，架构师有大量主题需要研究。事实上，本附
录中的材料是本书 1990年第一次出版时的中心内容，但现在它被放在附录中，主要作为参考
材料！

附录K 可以满足那些对指令集体系结构感兴趣的读者；其中介绍了各种指令集，这些指令
集要么在今天的市场上非常重要，要么从历史的角度来说非常重要，它将9种流行的载人-存储
计算机与MIPS进行了对比。

\section{历史回顾与参考文献}
附录L.4节讨论了指令集的演进，并给出了一些参考文献，供深人阅读和探讨相关主题。
练习（Gregory D. Peterson设计）
A.1 ［15］ <A.9>使用表A-13计算 MIPS的实际 CPI。假定我们已经对各指令类型的平均CPI进行了
以下测量：
指令
所有ALU指令
载人-存储
条件分支
选中
未选中
跳转
时钟周期
1.0
1.4
2.0
15
1.2
假定有 60%的条件分支被选中，表A-13中“其他”类别的所有指令都是ALUI指令。对 gep 和
gcc的指令频率求平均值，以获得指令比例。
A.2 ［15］<A.9>利用表A-13 和上表计算 MIIS的实际CPI。对gaip 和 perlbmk 的指令频率求平均值，
以获得指令比例。
A.3 ［20］<A.9>使用表A-14计算MIPS的实际CPI。假定我们已经对各指令类型的平均CPI进行了
以下测量：
指令
所有ALU指令
载人-存储
条件分支
选中
未选中
眺转
浮点乘
浮点加
浮点除
载人-存储浮点
其他浮点
肘钟圖期
1.0
1.4
2.0
15
1.2
6.0
4.0
20.0
1.5
2.0
假定有60%的条件分支被选中，表A-14中“其他”类别的所有指令都是 ALU 指令。对lucas
和swim 的指令频率求平均值，以获得指令比例。
A.4［20］<A.9>利用表A-14和上表计算MIIPS的实际 CPI。对 applu 和 art 的指令频率求平均值，以
获得指令比例。
A.3 ［10］<A.8>考虑下面这个由3行语句组成的高级代码序列：
A.12 历史回顾与参考文献
401
A=B+C；
B=A+C；
D= A-B；
使用复制传播技术（见表 A-8）将此代码序列转换为所有操作数都不是计算值的情况。注意这
种转换减少了语句计算任务的实例，以及加重这些任务的情况。为什么这意味着在试图满足优
化编译器的期望时所面对的技术挑战？
A.6
［30］<A.8>编译器优化可能会改进代码大小及/或性能。考虑 SPEC CPU2006套件中的一或多个
基准测试程序。使用可以使用的处理器和 GNU C编译器，采用无优化、-O1、-02 和-03来优
化程序。对比所得程序的性能和规模。并将所得结果与图A-13进行对比。
A.7 ［20/20］<A.2、A.9>考虑以下C代码段：
for （i= 0; ix= 100: it+）
｛ A［i］ =B［i］ +C；｝
假定A和B是64位整数的数组，C和1是64位整数。假定所有数据值及其地址都保存在存储器
中（A、B、C、1分别位于地址1000、3000、5000、7000处），但在对其进行操作时例外。假
定寄存器中的值在该循环的各次迭代之间丢失。
a.［20］<A.2、A.9>写出MIPS的代码。动态需要多少条指令？将执行多少次存储器数据引用？
代码大小为多少字节？
b.［20］<A.2>写出x86的代码。动态需要多少条指令？将执行多少次存储器数据引用？代码大
小为多少字节？
A.8 ［10/10/10］<A.2、A.7>对于以下练习，考虑针对指令集体系结构的指令编码。
2.［10］ <A.2、A.T>考虑以下情景：处理器的指令长度为12位，有32个通用寄存器，所以地址
字段的大小为5位。是否有可能拥有如下指令编码？
口 3个两地址指令
口 30个单地址指令
口 45个零地址措令
b.［10］ <A.2、A.7>假定指令长度和地址段大小如上所述，判断是否有可能拥有以下指令编码。
口 3个两地址指令
口 31个单地址指令
口 35个零地址指令
解释你的回答。
c.［10］<A.2、A.7>假定指令长度和地址段大小如上所述。进一步假定已经拥有3个两地址指令
和24个零地址指令。最多可以为这一处理器编码多少个单地址指令？
A.9 ［10/15］<A.2>对于以下练习，假定A、B、C、D、E和F驻存在存储器中。另外假定指令操作码
以8位表示，存储器地址为64位，寄存器地址为6位。
a. ［10］ <A.2>对于表A-1所示的每个指令集体系结构，对于计算 C=A+B 的代码，每条指令中出
现多少个地址或名称？总代码大小为多少？
b.［15］<A.2>表A-1中的一些指令集体系结构会在计算过程中销毁操作数。这种在处理器器内
部存储中丢失数据值的情况会造成性能影响。对于表A-1 中的每种体系结构，编写代码序列，
以计算：
C=A+B
D=A-E
F=C+D
在代码中，标出所有将在执行期间被销毁的操作数，有些指令的存在只是为了应对处理器内部
存储器的数据丢失，也请标出所有这些“开销”指令。对于每段代码序列，总代码大小、向（自）
存储器移动的指令与数据的字节数、开销指令的数量、开销数据字节的数目各为多少？
A.10［20］<A.2、A.7、A.9>MIPS的设计提供了32个通用寄存器和32个浮点寄存器。如果这些寄存
L-48
402
149
A-50
附录A 指令集基本原理
器表现良好，那包含更多寄存器是不是更好一些？当指令集体系结构设计人员在确定是否要增
加MIPS 寄存器、应当增加多少时，必需考虑一些折中，请尽你所能列出并讨论这些折中。
A.11 ［5］<A.3>考虑包含以下成员的C结构：
struct foo ｛
char a：
bool b；
int c；
double d；
short e：
float f；
double g；
char * cptr；
float * fptr；
int x；
｝；
对于32位机器，f00结构的大小为多少？假定可以任何安排结构成员的顺序，这一结构最小为
多少？对于64位机器呢？
A.12 ［30］<A.7>许多计算机制造商现在在处理器中包含了一些工具或模拟器，可以用来测量用户程
序的指令集使用情况。所使用的方法包括机器模拟、硬件支持的陷阱中断，还有一种编泽器技
术，通过插人计数器来测量目标代码模块。找一种自己能够使用并包含此种工具的处理器。用
它来测量每个 SPECCPU2006 基准测试的指令集比例。将测量结果与本章所示结果进行对比。
A.13 ［30］<A.8>诸如 Intel的i7 Sandy Bridge 等新处理器都支持 AVX向量/多媒体指令。编写一个使
用单精度值的密集矩阵相乘函数，并将用不同编译器和优化标志进行编译。使用基础线性代码
子例程（BLAS）（比如SGEMM）的线性代数代码包含了密集矩阵乘法的优化版本。对比你所
编写代码与 BLAS SGEMM代码的大小和性能。探讨在使用双精度值和 DGEMIMI时的情景。
A.14［30］<A.8>对于上面为i7处理器开发的 SGEMIM代码，使用AVX 内建函数来提高性能。具体来
说，尝试实现代码的向量化，以更好地利用AVX硬件。将其代码大小和性能与原代码进行对比。
A.i5 ［30］ <A.7、A.9>SPIM 是一种用于模拟MIPS处理器的流行模拟器。使用SPIM 来测量一些 SPEC
CPU2006 基准测试程序的指令集比例。
A.16
［35/35/35/3S］ <A.2-A.8>gcc的测试目标是最现代的指令集体系结构（参见 www.gnu.org/
sofware/gcc/）。针对你能够使用的几种体系结构（例如，x86、MIPS、PowerPC 和 ARM）创
建gcc的一个版本。
a.［35］ <A.2-A.8>编译 SPEC CPU2006整数基准测试的一部分，并绘制一个表格，列出其代码
大小。对于每个程序，哪种体系结构的运行效果最佳？
b.［35］ <A.2-A.8>编译 SPEC CPU2006淨点基准测试的一部分，并绘制一个表格，列出其代码
大小。对于每个程序，哪种体系结构的运行效果最佳？
c.［35］ <A.2-A.8>编译 EEMBC AutoBench 基准测试的一部分（参见www.cembc.org/home.php），
并绘制一个表格，列出其代码大小。对于每个程序，哪种体系结构的运行效果最佳？
d.［35］<A.2-A.8>编译EEMBC FPBench 浮点基准测试的一部分，并绘制一个表格，列出其代码
大小。对于每个程序，哪种体系结构的运行效果最佳？
A.17 ［40］<A.2-A.8>对于现代处理器，特别是嵌人式系统，功率效率已经变得非常重要。为你能使用
的两种体系结构（比如 x86、MIPS、Powe:PC 和ARM）创建一个gcc版本。编译一部分 EEMBC
基准测试，并使用 EnergyBench 来测试执行期间的能量使用情况。对比针对不同处理器的代码
大小、性能和能量使用。对于每个程序，哪种处理器的运行效果最佳？
A.18［20/15/15/20］你的任务是对比4种不同指令集体系结构的存储器效率。这4种体系结构类型如下所述。
口 累加器—所有操作都在单个寄存器和存储器位置之间进行。
口 存储器-存储器—所有指令地址仅引用存储器位置。
A.12 历史回顾与参考文献
403
口 栈—所有操作都在栈顶部执行。只有压入栈和弹出栈指令会访问存储器；所有其他指
令都删除其在栈中的操作效，代以结果。这种实施方式仅为顶部两个栈项使用硬连线栈，
这样可以使处理器电路保持小型化，并降低其成本。其他栈位置保存在存储器位置中，
对这些栈位置的访问需要进行存储器引用。
口 载入-存储——所有操作都是在寄存器中进行，每个寄存器至寄存器指令有3个寄存器
名称。
为了测量存储器效率，对所有4种指令集作出以下假定。
口所有指令的长度都是整数个字节。
口操作码的长度均为一个字节（8位）。
口存储器访问使用直接寻址或绝对寻址。
口变量A、B、C和D最初在存储器中。
a. ［20］<A.2、A.3>创建自己的汇编语言标记（表A-1提供了一个可供推广的有用示例），针对A-51
每种体系结构为以下高级语言代码序列编写最为等价的汇编语言代码：
A = 8 + C；
B=A+ C；
D = A- B；
b.［15］<A.3>对于（a）部分中编写的汇编代码，如果有一个值已经被载入一次后再次从存储器
中载入，请标出此类实例。如果一条指令的结果被作为操作数传递给另一条指令，也请标出，
并对这些情况进行分类，说明哪些涉及处理器内部的存储，哪些涉及存储器内部的存储。
c.［15］<A.7>假定给定的代码序列来自一个小型的嵌人式应用程序，比如微波炉控制器，它的
存储器地址和数据操作数为16位。如果使用载入-存储体系结构，则假定它有16个通用哥
存器。对于每种体系结构，回答以下问题：提取了多少个指令字节？向（从）寄存器传送多
少个数据字节？根据测得的总存储器通信流量（代码＋数据），哪种体系结构的效率最高？
d. ［20］<A.7>现在假定采用存储器地址和数据操作数为64位的处理器。针对每种体系结构，回
答（c）部分的问题。对于选定的度量，这些体系结构的相对优势有哪些变化？
A.19［30］<A.2、A.3>使用上面给出的4种不同指令集体系结构，但假定所支持的存储器操作包括寄
存器间接寻址和直接寻址。创建自己的汇编语言标记（表A-1提供了一个可供推广的有用示例），
针对每种体系结构为以下C代码段编写最为等价的汇编语言代码：
for （i = 0; i ≤= 100;i++）
｛ A［i］ -B［i］+C；｝
假定A和B是64位整数的数组，C和1是64位整数。
第二列和第三列分别包含数据引用和分支的累积百分比，可以在位移量中用相应的位数来提供
这些引用和分支。这是图A-4和图A-9中所有弊数与浮点程序的平均距离。
A.20［20/20/20］＜A.3>我们正在为一种载人-存储体系结构设计指令集格式，并试图判断是否值得为
分支和存储器引用包含多种偏移长度。一条指令的长度等于（16+偏移长度）位，所以 ALU指
令的长度为16位。表A-16包含了 Alpha 体系结构的偏移量大小数据，其中针对 SPEC CPU2000
进行了完全优化。关于指令集频率，使用表A-13中5种基准测试针对载人-存储机器测得的
MIPS 平均数据。假定其他指令均为仅使用寄存器的ALU措令。
A-52
表A-16 Alpha体系结构的偏移量大小数据，对SPEC CPU2000进行了全面优化
偏移量的位数
累积数据引用
0
30.4%
33.5%
2
3
35.0%
40.0%
黑积分支
0.1%
2.8%
10.5%
22.9%
404
附录A 指令集基本原理
（续）
A-53
A-54
偏移量的位效
4
5
累积数据引用
累积分支
47.3%
36.5%
54.5%
57.4%
60.4%
72.4%
66.9%
85.2%
8
71.6%
90.5%
9
73.3%
93.1%
、
10
74.2%
95.1%
11
74.9%
96.0%
12
76.6%
96.8%
13
87.9%
97.4%
14
91.9%
98.1%
15
100%
98.5%
16
100%
99.5%
17
100%
99.8%
18
100%
99.9%
19
100%
100%
20
100%
100%
21
100%
100%
a.［20］<A.3>假定允许偏移量的长度为0、8、16或24位，包括符号位在内。所执行指令的平
均长度是多少？
b.［20］<A.3>假定我们希望有固定长度的指令，并选择指令长度24位（所有指令均如此，包
括 ALU指令）。对于每个大于8位的偏移量，需要增加指令。判断在这种采用固定指令太
度的机器中所提取的指令字节数，并对比（a）部分定义的变长指令中所提取的字节数。
c.［20］<A.3>现在假定我们使用24位的固定偏移量长度，所以不需要额外指令。需要多少指令
字节数？将这一结果与（b） 部分的答案进行对比。
A.21 ［20/20］<A.3、A.6、A.9>位移量寻址方式或PC 相对寻址方式的位移值大小可以从编译后的应用
程序中获取。对于针对 MIPS处理器编译的一或多个 SPEC CPU2006基准测试使用反汇编程序。
2. ［201<A.3、A.9>对于每条使用位移量寻址的指令，记录所使用的位移量值。生成位移量值的
一个直方图。将这里所示的结果与图A-4中所示的结果进行对比。
b.［20］ <A.6、A.9>对于每条使用PC.相对寻址的指令，记录所使用的位移量值。生成位称量值
的一个直方图。将这里所示的结果与图A-9中所示的结果进行对比。
A.22 ［15/15/10/10］<A.3>—数值用十六进制数字 434F 4D50 55544552表示，将其存储在64位对齐双
字中。
a. ［15］<A.3>使用图 A-2中第一行的物理排列，用大端字节顺序写出要存储的值。接下来，将每个
字节解读为ASCI字符，在每个字节下面写出相应的字符，形成将要以大端顺序存储的字符串。
b.［15］ <A.3>使用（a）部分中的相同物理排列，用小端字节顺序写出要存储的址，并在每个字节
下面写出相应的ASCII字节。
c.［10］ <A.3>当以大端字节顺序存储时，可以从给定64位双字中读取的所有非对齐2字节字的
十六进制取值为多少？
d. ［10］ <A.3>当以小端字节顺序存储时，可以从给定64位双字中读取的所有非对齐4字节字的
十六进制取值为多少？
A.23［讨论】<A.2-A.12>考虑桌面、服务器、云和嵌人式计算的典型应用程序。对于面向这些市场的
计算机而言，指令集体系结构将会受到什么样的影响？